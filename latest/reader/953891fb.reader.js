(function(global) {
    
    var EPUBcfi = {};

    EPUBcfi.Parser = (function(){
  /*
   * Generated by PEG.js 0.7.0.
   *
   * http://pegjs.majda.cz/
   */
  
  function quote(s) {
    /*
     * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a
     * string literal except for the closing quote character, backslash,
     * carriage return, line separator, paragraph separator, and line feed.
     * Any character may appear in the form of an escape sequence.
     *
     * For portability, we also escape escape all control and non-ASCII
     * characters. Note that "\0" and "\v" escape sequences are not used
     * because JSHint does not like the first and IE the second.
     */
     return '"' + s
      .replace(/\\/g, '\\\\')  // backslash
      .replace(/"/g, '\\"')    // closing quote character
      .replace(/\x08/g, '\\b') // backspace
      .replace(/\t/g, '\\t')   // horizontal tab
      .replace(/\n/g, '\\n')   // line feed
      .replace(/\f/g, '\\f')   // form feed
      .replace(/\r/g, '\\r')   // carriage return
      .replace(/[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g, escape)
      + '"';
  }
  
  var result = {
    /*
     * Parses the input with a generated parser. If the parsing is successfull,
     * returns a value explicitly or implicitly specified by the grammar from
     * which the parser was generated (see |PEG.buildParser|). If the parsing is
     * unsuccessful, throws |PEG.parser.SyntaxError| describing the error.
     */
    parse: function(input, startRule) {
      var parseFunctions = {
        "fragment": parse_fragment,
        "path": parse_path,
        "local_path": parse_local_path,
        "indexStep": parse_indexStep,
        "indirectionStep": parse_indirectionStep,
        "terminus": parse_terminus,
        "idAssertion": parse_idAssertion,
        "textLocationAssertion": parse_textLocationAssertion,
        "parameter": parse_parameter,
        "csv": parse_csv,
        "valueNoSpace": parse_valueNoSpace,
        "value": parse_value,
        "escapedSpecialChars": parse_escapedSpecialChars,
        "number": parse_number,
        "integer": parse_integer,
        "space": parse_space,
        "circumflex": parse_circumflex,
        "doubleQuote": parse_doubleQuote,
        "squareBracket": parse_squareBracket,
        "parentheses": parse_parentheses,
        "comma": parse_comma,
        "semicolon": parse_semicolon,
        "equal": parse_equal,
        "character": parse_character
      };
      
      if (startRule !== undefined) {
        if (parseFunctions[startRule] === undefined) {
          throw new Error("Invalid rule name: " + quote(startRule) + ".");
        }
      } else {
        startRule = "fragment";
      }
      
      var pos = 0;
      var reportFailures = 0;
      var rightmostFailuresPos = 0;
      var rightmostFailuresExpected = [];
      
      function padLeft(input, padding, length) {
        var result = input;
        
        var padLength = length - input.length;
        for (var i = 0; i < padLength; i++) {
          result = padding + result;
        }
        
        return result;
      }
      
      function escape(ch) {
        var charCode = ch.charCodeAt(0);
        var escapeChar;
        var length;
        
        if (charCode <= 0xFF) {
          escapeChar = 'x';
          length = 2;
        } else {
          escapeChar = 'u';
          length = 4;
        }
        
        return '\\' + escapeChar + padLeft(charCode.toString(16).toUpperCase(), '0', length);
      }
      
      function matchFailed(failure) {
        if (pos < rightmostFailuresPos) {
          return;
        }
        
        if (pos > rightmostFailuresPos) {
          rightmostFailuresPos = pos;
          rightmostFailuresExpected = [];
        }
        
        rightmostFailuresExpected.push(failure);
      }
      
      function parse_fragment() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 8) === "epubcfi(") {
          result0 = "epubcfi(";
          pos += 8;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"epubcfi(\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_path();
          if (result1 !== null) {
            if (input.charCodeAt(pos) === 41) {
              result2 = ")";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\")\"");
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, pathVal) { 
                
                return { type:"CFIAST", cfiString:pathVal }; 
            })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_path() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_indexStep();
        if (result0 !== null) {
          result1 = parse_local_path();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, stepVal, localPathVal) { 
        
                return { type:"cfiString", path:stepVal, localPath:localPathVal }; 
            })(pos0, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_local_path() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result1 = parse_indexStep();
        if (result1 === null) {
          result1 = parse_indirectionStep();
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_indexStep();
            if (result1 === null) {
              result1 = parse_indirectionStep();
            }
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result1 = parse_terminus();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, localPathStepVal, termStepVal) { 
        
                return { steps:localPathStepVal, termStep:termStepVal }; 
            })(pos0, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_indexStep() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 47) {
          result0 = "/";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"/\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_integer();
          if (result1 !== null) {
            pos2 = pos;
            if (input.charCodeAt(pos) === 91) {
              result2 = "[";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"[\"");
              }
            }
            if (result2 !== null) {
              result3 = parse_idAssertion();
              if (result3 !== null) {
                if (input.charCodeAt(pos) === 93) {
                  result4 = "]";
                  pos++;
                } else {
                  result4 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"]\"");
                  }
                }
                if (result4 !== null) {
                  result2 = [result2, result3, result4];
                } else {
                  result2 = null;
                  pos = pos2;
                }
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, stepLengthVal, assertVal) { 
        
                return { type:"indexStep", stepLength:stepLengthVal, idAssertion:assertVal[1] };
            })(pos0, result0[1], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_indirectionStep() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 2) === "!/") {
          result0 = "!/";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"!/\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_integer();
          if (result1 !== null) {
            pos2 = pos;
            if (input.charCodeAt(pos) === 91) {
              result2 = "[";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"[\"");
              }
            }
            if (result2 !== null) {
              result3 = parse_idAssertion();
              if (result3 !== null) {
                if (input.charCodeAt(pos) === 93) {
                  result4 = "]";
                  pos++;
                } else {
                  result4 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"]\"");
                  }
                }
                if (result4 !== null) {
                  result2 = [result2, result3, result4];
                } else {
                  result2 = null;
                  pos = pos2;
                }
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, stepLengthVal, assertVal) { 
        
                return { type:"indirectionStep", stepLength:stepLengthVal, idAssertion:assertVal[1] };
            })(pos0, result0[1], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_terminus() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 58) {
          result0 = ":";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\":\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_integer();
          if (result1 !== null) {
            pos2 = pos;
            if (input.charCodeAt(pos) === 91) {
              result2 = "[";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"[\"");
              }
            }
            if (result2 !== null) {
              result3 = parse_textLocationAssertion();
              if (result3 !== null) {
                if (input.charCodeAt(pos) === 93) {
                  result4 = "]";
                  pos++;
                } else {
                  result4 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"]\"");
                  }
                }
                if (result4 !== null) {
                  result2 = [result2, result3, result4];
                } else {
                  result2 = null;
                  pos = pos2;
                }
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, textOffsetValue, textLocAssertVal) { 
        
                return { type:"textTerminus", offsetValue:textOffsetValue, textAssertion:textLocAssertVal[1] };
            })(pos0, result0[1], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_idAssertion() {
        var result0;
        var pos0;
        
        pos0 = pos;
        result0 = parse_value();
        if (result0 !== null) {
          result0 = (function(offset, idVal) { 
        
                return idVal; 
            })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_textLocationAssertion() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_csv();
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          result1 = parse_parameter();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, csvVal, paramVal) { 
        
                return { type:"textLocationAssertion", csv:csvVal, parameter:paramVal }; 
            })(pos0, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_parameter() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 59) {
          result0 = ";";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\";\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_valueNoSpace();
          if (result1 !== null) {
            if (input.charCodeAt(pos) === 61) {
              result2 = "=";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"=\"");
              }
            }
            if (result2 !== null) {
              result3 = parse_valueNoSpace();
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, paramLHSVal, paramRHSVal) { 
        
                return { type:"parameter", LHSValue:paramLHSVal, RHSValue:paramRHSVal }; 
            })(pos0, result0[1], result0[3]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_csv() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_value();
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 44) {
            result1 = ",";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\",\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_value();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, preAssertionVal, postAssertionVal) { 
        
                return { type:"csv", preAssertion:preAssertionVal, postAssertion:postAssertionVal }; 
            })(pos0, result0[0], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_valueNoSpace() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result1 = parse_escapedSpecialChars();
        if (result1 === null) {
          result1 = parse_character();
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_escapedSpecialChars();
            if (result1 === null) {
              result1 = parse_character();
            }
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset, stringVal) { 
        
                return stringVal.join(''); 
            })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_value() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result1 = parse_escapedSpecialChars();
        if (result1 === null) {
          result1 = parse_character();
          if (result1 === null) {
            result1 = parse_space();
          }
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_escapedSpecialChars();
            if (result1 === null) {
              result1 = parse_character();
              if (result1 === null) {
                result1 = parse_space();
              }
            }
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset, stringVal) { 
        
                return stringVal.join(''); 
            })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_escapedSpecialChars() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_circumflex();
        if (result0 !== null) {
          result1 = parse_circumflex();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 === null) {
          pos1 = pos;
          result0 = parse_circumflex();
          if (result0 !== null) {
            result1 = parse_squareBracket();
            if (result1 !== null) {
              result0 = [result0, result1];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 === null) {
            pos1 = pos;
            result0 = parse_circumflex();
            if (result0 !== null) {
              result1 = parse_parentheses();
              if (result1 !== null) {
                result0 = [result0, result1];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 === null) {
              pos1 = pos;
              result0 = parse_circumflex();
              if (result0 !== null) {
                result1 = parse_comma();
                if (result1 !== null) {
                  result0 = [result0, result1];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
              if (result0 === null) {
                pos1 = pos;
                result0 = parse_circumflex();
                if (result0 !== null) {
                  result1 = parse_semicolon();
                  if (result1 !== null) {
                    result0 = [result0, result1];
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
                if (result0 === null) {
                  pos1 = pos;
                  result0 = parse_circumflex();
                  if (result0 !== null) {
                    result1 = parse_equal();
                    if (result1 !== null) {
                      result0 = [result0, result1];
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                }
              }
            }
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, escSpecCharVal) { 
                
                return escSpecCharVal[1]; 
            })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_number() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        pos2 = pos;
        if (/^[1-9]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[1-9]");
          }
        }
        if (result0 !== null) {
          if (/^[0-9]/.test(input.charAt(pos))) {
            result2 = input.charAt(pos);
            pos++;
          } else {
            result2 = null;
            if (reportFailures === 0) {
              matchFailed("[0-9]");
            }
          }
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              if (/^[0-9]/.test(input.charAt(pos))) {
                result2 = input.charAt(pos);
                pos++;
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("[0-9]");
                }
              }
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos2;
          }
        } else {
          result0 = null;
          pos = pos2;
        }
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 46) {
            result1 = ".";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\".\"");
            }
          }
          if (result1 !== null) {
            pos2 = pos;
            result2 = [];
            if (/^[0-9]/.test(input.charAt(pos))) {
              result3 = input.charAt(pos);
              pos++;
            } else {
              result3 = null;
              if (reportFailures === 0) {
                matchFailed("[0-9]");
              }
            }
            while (result3 !== null) {
              result2.push(result3);
              if (/^[0-9]/.test(input.charAt(pos))) {
                result3 = input.charAt(pos);
                pos++;
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("[0-9]");
                }
              }
            }
            if (result2 !== null) {
              if (/^[1-9]/.test(input.charAt(pos))) {
                result3 = input.charAt(pos);
                pos++;
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("[1-9]");
                }
              }
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, intPartVal, fracPartVal) { 
        
                return intPartVal.join('') + "." + fracPartVal.join(''); 
            })(pos0, result0[0], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_integer() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 48) {
          result0 = "0";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"0\"");
          }
        }
        if (result0 === null) {
          pos1 = pos;
          if (/^[1-9]/.test(input.charAt(pos))) {
            result0 = input.charAt(pos);
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("[1-9]");
            }
          }
          if (result0 !== null) {
            result1 = [];
            if (/^[0-9]/.test(input.charAt(pos))) {
              result2 = input.charAt(pos);
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("[0-9]");
              }
            }
            while (result2 !== null) {
              result1.push(result2);
              if (/^[0-9]/.test(input.charAt(pos))) {
                result2 = input.charAt(pos);
                pos++;
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("[0-9]");
                }
              }
            }
            if (result1 !== null) {
              result0 = [result0, result1];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, integerVal) { 
        
                if (integerVal === "0") { 
                  return "0";
                } 
                else { 
                  return integerVal[0].concat(integerVal[1].join(''));
                }
            })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_space() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 32) {
          result0 = " ";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\" \"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) { return " "; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_circumflex() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 94) {
          result0 = "^";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"^\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) { return "^"; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_doubleQuote() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 34) {
          result0 = "\"";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\\"\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) { return '"'; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_squareBracket() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 91) {
          result0 = "[";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"[\"");
          }
        }
        if (result0 === null) {
          if (input.charCodeAt(pos) === 93) {
            result0 = "]";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"]\"");
            }
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, bracketVal) { return bracketVal; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_parentheses() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 40) {
          result0 = "(";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"(\"");
          }
        }
        if (result0 === null) {
          if (input.charCodeAt(pos) === 41) {
            result0 = ")";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\")\"");
            }
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, paraVal) { return paraVal; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_comma() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 44) {
          result0 = ",";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\",\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) { return ","; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_semicolon() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 59) {
          result0 = ";";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\";\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) { return ";"; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_equal() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 61) {
          result0 = "=";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"=\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) { return "="; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_character() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (/^[a-z]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[a-z]");
          }
        }
        if (result0 === null) {
          if (/^[A-Z]/.test(input.charAt(pos))) {
            result0 = input.charAt(pos);
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("[A-Z]");
            }
          }
          if (result0 === null) {
            if (/^[0-9]/.test(input.charAt(pos))) {
              result0 = input.charAt(pos);
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("[0-9]");
              }
            }
            if (result0 === null) {
              if (input.charCodeAt(pos) === 45) {
                result0 = "-";
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"-\"");
                }
              }
              if (result0 === null) {
                if (input.charCodeAt(pos) === 95) {
                  result0 = "_";
                  pos++;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"_\"");
                  }
                }
              }
            }
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, charVal) { return charVal; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      
      function cleanupExpected(expected) {
        expected.sort();
        
        var lastExpected = null;
        var cleanExpected = [];
        for (var i = 0; i < expected.length; i++) {
          if (expected[i] !== lastExpected) {
            cleanExpected.push(expected[i]);
            lastExpected = expected[i];
          }
        }
        return cleanExpected;
      }
      
      function computeErrorPosition() {
        /*
         * The first idea was to use |String.split| to break the input up to the
         * error position along newlines and derive the line and column from
         * there. However IE's |split| implementation is so broken that it was
         * enough to prevent it.
         */
        
        var line = 1;
        var column = 1;
        var seenCR = false;
        
        for (var i = 0; i < Math.max(pos, rightmostFailuresPos); i++) {
          var ch = input.charAt(i);
          if (ch === "\n") {
            if (!seenCR) { line++; }
            column = 1;
            seenCR = false;
          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
            line++;
            column = 1;
            seenCR = true;
          } else {
            column++;
            seenCR = false;
          }
        }
        
        return { line: line, column: column };
      }
      
      
      var result = parseFunctions[startRule]();
      
      /*
       * The parser is now in one of the following three states:
       *
       * 1. The parser successfully parsed the whole input.
       *
       *    - |result !== null|
       *    - |pos === input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 2. The parser successfully parsed only a part of the input.
       *
       *    - |result !== null|
       *    - |pos < input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 3. The parser did not successfully parse any part of the input.
       *
       *   - |result === null|
       *   - |pos === 0|
       *   - |rightmostFailuresExpected| contains at least one failure
       *
       * All code following this comment (including called functions) must
       * handle these states.
       */
      if (result === null || pos !== input.length) {
        var offset = Math.max(pos, rightmostFailuresPos);
        var found = offset < input.length ? input.charAt(offset) : null;
        var errorPosition = computeErrorPosition();
        
        throw new this.SyntaxError(
          cleanupExpected(rightmostFailuresExpected),
          found,
          offset,
          errorPosition.line,
          errorPosition.column
        );
      }
      
      return result;
    },
    
    /* Returns the parser source code. */
    toSource: function() { return this._source; }
  };
  
  /* Thrown when a parser encounters a syntax error. */
  
  result.SyntaxError = function(expected, found, offset, line, column) {
    function buildMessage(expected, found) {
      var expectedHumanized, foundHumanized;
      
      switch (expected.length) {
        case 0:
          expectedHumanized = "end of input";
          break;
        case 1:
          expectedHumanized = expected[0];
          break;
        default:
          expectedHumanized = expected.slice(0, expected.length - 1).join(", ")
            + " or "
            + expected[expected.length - 1];
      }
      
      foundHumanized = found ? quote(found) : "end of input";
      
      return "Expected " + expectedHumanized + " but " + foundHumanized + " found.";
    }
    
    this.name = "SyntaxError";
    this.expected = expected;
    this.found = found;
    this.message = buildMessage(expected, found);
    this.offset = offset;
    this.line = line;
    this.column = column;
  };
  
  result.SyntaxError.prototype = Error.prototype;
  
  return result;
})();
 

    // Description: This model contains the implementation for "instructions" included in the EPUB CFI domain specific language (DSL). 
//   Lexing and parsing a CFI produces a set of executable instructions for processing a CFI (represented in the AST). 
//   This object contains a set of functions that implement each of the executable instructions in the AST. 

EPUBcfi.CFIInstructions = {

	// ------------------------------------------------------------------------------------ //
	//  "PUBLIC" METHODS (THE API)                                                          //
	// ------------------------------------------------------------------------------------ //

	// Description: Follows a step
	// Rationale: The use of children() is important here, as this jQuery method returns a tree of xml nodes, EXCLUDING
	//   CDATA and text nodes. When we index into the set of child elements, we are assuming that text nodes have been 
	//   excluded.
	// REFACTORING CANDIDATE: This should be called "followIndexStep"
	getNextNode : function (CFIStepValue, $currNode, classBlacklist, elementBlacklist, idBlacklist) {

		// Find the jquery index for the current node
		var $targetNode;
		if (CFIStepValue % 2 == 0) {

			$targetNode = this.elementNodeStep(CFIStepValue, $currNode, classBlacklist, elementBlacklist, idBlacklist);
		}
		else {

			$targetNode = this.inferTargetTextNode(CFIStepValue, $currNode, classBlacklist, elementBlacklist, idBlacklist);
		}

		return $targetNode;
	},

	// Description: This instruction executes an indirection step, where a resource is retrieved using a 
	//   link contained on a attribute of the target element. The attribute that contains the link differs
	//   depending on the target. 
	// Note: Iframe indirection will (should) fail if the iframe is not from the same domain as its containing script due to 
	//   the cross origin security policy
	followIndirectionStep : function (CFIStepValue, $currNode, classBlacklist, elementBlacklist, idBlacklist) {

		var that = this;
		var $contentDocument; 
		var $blacklistExcluded;
		var $startElement;
		var $targetNode;

		// TODO: This check must be expanded to all the different types of indirection step
		// Only expects iframes, at the moment
		if ($currNode === undefined || !$currNode.is("iframe")) {

			throw EPUBcfi.NodeTypeError($currNode, "expected an iframe element");
		}

		// Check node type; only iframe indirection is handled, at the moment
		if ($currNode.is("iframe")) {

			// Get content
			$contentDocument = $currNode.contents();

			// Go to the first XHTML element, which will be the first child of the top-level document object
			$blacklistExcluded = this.applyBlacklist($contentDocument.children(), classBlacklist, elementBlacklist, idBlacklist);
			$startElement = $($blacklistExcluded[0]);

			// Follow an index step
			$targetNode = this.getNextNode(CFIStepValue, $startElement, classBlacklist, elementBlacklist, idBlacklist);

			// Return that shit!
			return $targetNode; 
		}

		// TODO: Other types of indirection
		// TODO: $targetNode.is("embed")) : src
		// TODO: ($targetNode.is("object")) : data
		// TODO: ($targetNode.is("image") || $targetNode.is("xlink:href")) : xlink:href
	},

	// Description: Injects an element at the specified text node
	// Arguments: a cfi text termination string, a jquery object to the current node
	// REFACTORING CANDIDATE: Rename this to indicate that it injects into a text terminus
	textTermination : function ($currNode, textOffset, elementToInject) {

		// Get the first node, this should be a text node
		if ($currNode === undefined) {

			throw EPUBcfi.NodeTypeError($currNode, "expected a terminating node, or node list");
		} 
		else if ($currNode.length === 0) {

			throw EPUBcfi.TerminusError("Text", "Text offset:" + textOffset, "no nodes found for termination condition");
		}

		$currNode = this.injectCFIMarkerIntoText($currNode, textOffset, elementToInject);
		return $currNode;
	},

	// Description: Checks that the id assertion for the node target matches that on 
	//   the found node. 
	targetIdMatchesIdAssertion : function ($foundNode, idAssertion) {

		if ($foundNode.attr("id") === idAssertion) {

			return true;
		}
		else {

			return false;
		}
	},

	// ------------------------------------------------------------------------------------ //
	//  "PRIVATE" HELPERS                                                                   //
	// ------------------------------------------------------------------------------------ //

	// Description: Step reference for xml element node. Expected that CFIStepValue is an even integer
	elementNodeStep : function (CFIStepValue, $currNode, classBlacklist, elementBlacklist, idBlacklist) {

		var $targetNode;
		var $blacklistExcluded;
		var numElements;
		var jqueryTargetNodeIndex = (CFIStepValue / 2) - 1;

		$blacklistExcluded = this.applyBlacklist($currNode.children(), classBlacklist, elementBlacklist, idBlacklist);
		numElements = $blacklistExcluded.length;

		if (this.indexOutOfRange(jqueryTargetNodeIndex, numElements)) {

			throw EPUBcfi.OutOfRangeError(jqueryTargetNodeIndex, numElements - 1, "");
		}

	    $targetNode = $($blacklistExcluded[jqueryTargetNodeIndex]);
		return $targetNode;
	},

	retrieveItemRefHref : function ($itemRefElement, $packageDocument) {

		return $("#" + $itemRefElement.attr("idref"), $packageDocument).attr("href");
	},

	indexOutOfRange : function (targetIndex, numChildElements) {

		return (targetIndex > numChildElements - 1) ? true : false;
	},

	// Rationale: In order to inject an element into a specific position, access to the parent object 
	//   is required. This is obtained with the jquery parent() method. An alternative would be to 
	//   pass in the parent with a filtered list containing only children that are part of the target text node.
	injectCFIMarkerIntoText : function ($textNodeList, textOffset, elementToInject) {

		var nodeNum;
		var currNodeLength;
		var currNodeMaxIndex = 0;
		var currTextPosition = 0;
		var nodeOffset;
		var originalText;
		var $injectedNode;
		var $newTextNode;
		// The iteration counter may be incorrect here (should be $textNodeList.length - 1 ??)
    for (nodeNum = 0; nodeNum < $textNodeList.length; nodeNum++) {

			if ($textNodeList[nodeNum].nodeType === 3) {

				currNodeMaxIndex = $textNodeList[nodeNum].nodeValue.length + currTextPosition;
				nodeOffset = textOffset - currTextPosition;

				if (currNodeMaxIndex > textOffset) {

					// This node is going to be split and the components re-inserted
					originalText = $textNodeList[nodeNum].nodeValue;	

					// Before part
				 	$textNodeList[nodeNum].nodeValue = originalText.slice(0, nodeOffset);

					// Injected element
					$injectedNode = $(elementToInject).insertAfter($textNodeList.eq(nodeNum));

					// After part
					$newTextNode = $(document.createTextNode(originalText.slice(nodeOffset, originalText.length)));
					$($newTextNode).insertAfter($injectedNode);

					return $textNodeList.parent();
				}
				else if (currNodeMaxIndex === textOffset) {
					//the node should be injected directly after the complete text node
					$injectedNode = $(elementToInject).insertAfter($textNodeList.eq(nodeNum));
					return $textNodeList.parent();
				}
				else {
					currTextPosition = currNodeMaxIndex;
				}
			}
		}

		throw EPUBcfi.TerminusError("Text", "Text offset:" + textOffset, "The offset exceeded the length of the text");
	},

	// Description: This method finds a target text node and then injects an element into the appropriate node
	// Arguments: A step value that is an odd integer. A current node with a set of child elements.
	// Rationale: The possibility that cfi marker elements have been injected into a text node at some point previous to 
	//   this method being called (and thus splitting the original text node into two separate text nodes) necessitates that
	//   the set of nodes that compromised the original target text node are inferred and returned.
	// Notes: Passed a current node. This node should have a set of elements under it. This will include at least one text node, 
	//   element nodes (maybe), or possibly a mix. 
	// REFACTORING CANDIDATE: This method is pretty long. Worth investigating to see if it can be refactored into something clearer.
	inferTargetTextNode : function (CFIStepValue, $currNode, classBlacklist, elementBlacklist, idBlacklist) {
		
		var $elementsWithoutMarkers;
		var currTextNodePosition;
		var logicalTargetPosition;
		var nodeNum;
		var $targetTextNodeList;

		// Remove any cfi marker elements from the set of elements. 
		// Rationale: A filtering function is used, as simply using a class selector with jquery appears to 
		//   result in behaviour where text nodes are also filtered out, along with the class element being filtered.
		$elementsWithoutMarkers = this.applyBlacklist($currNode.contents(), classBlacklist, elementBlacklist, idBlacklist);

		// Convert CFIStepValue to logical index; assumes odd integer for the step value
		logicalTargetPosition = (parseInt(CFIStepValue) + 1) / 2;

		// Set text node position counter
		currTextNodePosition = 1;
		$targetTextNodeList = $elementsWithoutMarkers.filter(
			function () {

				if (currTextNodePosition === logicalTargetPosition) {

					// If it's a text node
					if (this.nodeType === 3) {
						return true; 
					}
					// Any other type of node, move onto the next text node
					else {
						currTextNodePosition++; 
						return false;
					}
				}
				// In this case, don't return any elements
				else {

					// If its the last child and it's not a text node, there are no text nodes after it
					// and the currTextNodePosition shouldn't be incremented
					if (this.nodeType !== 3 && this !== $elementsWithoutMarkers.lastChild) {
						currTextNodePosition++;
					}

					return false;
				}
			}
		);

		// The filtering above should have counted the number of "logical" text nodes; this can be used to 
		// detect out of range errors
		if ($targetTextNodeList.length === 0) {

			throw EPUBcfi.OutOfRangeError(logicalTargetPosition, currTextNodePosition - 1, "Index out of range");
		}

		// return the text node list
		return $targetTextNodeList;
	},

	applyBlacklist : function ($elements, classBlacklist, elementBlacklist, idBlacklist) {

        var $filteredElements;

        $filteredElements = $elements.filter(
            function () {

                var $currElement = $(this);
                var includeInList = true;

                if (classBlacklist) {

                	// Filter each element with the class type
                	$.each(classBlacklist, function (index, value) {

	                    if ($currElement.hasClass(value)) {
	                    	includeInList = false;

	                    	// Break this loop
	                        return false;
	                    }
                	});
                }

                if (elementBlacklist) {
                	
	                // For each type of element
	                $.each(elementBlacklist, function (index, value) {

	                    if ($currElement.is(value)) {
	                    	includeInList = false;

	                    	// Break this loop
	                        return false;
	                    }
	                });
				}

				if (idBlacklist) {
                	
	                // For each type of element
	                $.each(idBlacklist, function (index, value) {

	                    if ($currElement.attr("id") === value) {
	                    	includeInList = false;

	                    	// Break this loop
	                        return false;
	                    }
	                });
				}

                return includeInList;
            }
        );

        return $filteredElements;
    }
};




    // Description: This is an interpreter that inteprets an Abstract Syntax Tree (AST) for a CFI. The result of executing the interpreter
//   is to inject an element, or set of elements, into an EPUB content document (which is just an XHTML document). These element(s) will
//   represent the position or area in the EPUB referenced by a CFI.
// Rationale: The AST is a clean and readable expression of the step-terminus structure of a CFI. Although building an interpreter adds to the
//   CFI infrastructure, it provides a number of benefits. First, it emphasizes a clear separation of concerns between lexing/parsing a
//   CFI, which involves some complexity related to escaped and special characters, and the execution of the underlying set of steps 
//   represented by the CFI. Second, it will be easier to extend the interpreter to account for new/altered CFI steps (say for references
//   to vector objects or multiple CFIs) than if lexing, parsing and interpretation were all handled in a single step. Finally, Readium's objective is 
//   to demonstrate implementation of the EPUB 3.0 spec. An implementation with a strong separation of concerns that conforms to 
//   well-understood patterns for DSL processing should be easier to communicate, analyze and understand. 
// REFACTORING CANDIDATE: node type errors shouldn't really be possible if the CFI syntax is correct and the parser is error free. 
//   Might want to make the script die in those instances, once the grammar and interpreter are more stable. 
// REFACTORING CANDIDATE: The use of the 'nodeType' property is confusing as this is a DOM node property and the two are unrelated. 
//   Whoops. There shouldn't be any interference, however, I think this should be changed. 

EPUBcfi.Interpreter = {

    // ------------------------------------------------------------------------------------ //
    //  "PUBLIC" METHODS (THE API)                                                          //
    // ------------------------------------------------------------------------------------ //

    // Description: Find the content document referenced by the spine item. This should be the spine item 
    //   referenced by the first indirection step in the CFI.
    // Rationale: This method is a part of the API so that the reading system can "interact" the content document 
    //   pointed to by a CFI. If this is not a separate step, the processing of the CFI must be tightly coupled with 
    //   the reading system, as it stands now. 
    getContentDocHref : function (CFI, packageDocument, classBlacklist, elementBlacklist, idBlacklist) {

        // Decode for URI/IRI escape characters
        var $packageDocument = $(packageDocument);
        var decodedCFI = decodeURI(CFI);
        var CFIAST = EPUBcfi.Parser.parse(decodedCFI);

        // Check node type; throw error if wrong type
        if (CFIAST === undefined || CFIAST.type !== "CFIAST") { 

            throw EPUBcfi.NodeTypeError(CFIAST, "expected CFI AST root node");
        }

        var $packageElement = $($("package", $packageDocument)[0]);

        // Interpet the path node (the package document step)
        var $currElement = this.interpretIndexStepNode(CFIAST.cfiString.path, $packageElement, classBlacklist, elementBlacklist, idBlacklist);

        // Interpret the local_path node, which is a set of steps and and a terminus condition
        var stepNum = 0;
        var nextStepNode;
        for (stepNum = 0 ; stepNum <= CFIAST.cfiString.localPath.steps.length - 1 ; stepNum++) {
        
            nextStepNode = CFIAST.cfiString.localPath.steps[stepNum];
            if (nextStepNode.type === "indexStep") {

                $currElement = this.interpretIndexStepNode(nextStepNode, $currElement, classBlacklist, elementBlacklist, idBlacklist);
            }
            else if (nextStepNode.type === "indirectionStep") {

                $currElement = this.interpretIndirectionStepNode(nextStepNode, $currElement, classBlacklist, elementBlacklist, idBlacklist);
            }

            // Found the content document href referenced by the spine item 
            if ($currElement.is("itemref")) {

                return EPUBcfi.CFIInstructions.retrieveItemRefHref($currElement, $packageDocument);
            }
        }

        // TODO: If you get to here, an itemref element was never found - a runtime error. The cfi is misspecified or 
        //   the package document is messed up.
    },

    // Description: Inject an arbitrary html element into a position in a content document referenced by a CFI
    injectElement : function (CFI, contentDocument, elementToInject, classBlacklist, elementBlacklist, idBlacklist) {

        var decodedCFI = decodeURI(CFI);
        var CFIAST = EPUBcfi.Parser.parse(decodedCFI);
        var indirectionNode;
        var indirectionStepNum;

        // Rationale: Since the correct content document for this CFI is already being passed, we can skip to the beginning 
        //   of the indirection step that referenced the content document.
        // Note: This assumes that indirection steps and index steps conform to an interface: an object with stepLength, idAssertion
        indirectionStepNum = this.getFirstIndirectionStepNum(CFIAST);
        indirectionNode = CFIAST.cfiString.localPath.steps[indirectionStepNum];
        indirectionNode.type = "indexStep";

        // Interpret the rest of the steps
        $currElement = this.interpretLocalPath(CFIAST.cfiString, indirectionStepNum, $("html", contentDocument), classBlacklist, elementBlacklist, idBlacklist);

        // TODO: detect what kind of terminus; for now, text node termini are the only kind implemented
        $currElement = this.interpretTextTerminusNode(CFIAST.cfiString.localPath.termStep, $currElement, elementToInject);

        // Return the element that was injected into
        return $currElement;
    },

    // Description: This method will return the element or node (say, a text node) that is the final target of the 
    //   the CFI.
    getTargetElement : function (CFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist) {

        var decodedCFI = decodeURI(CFI);
        var CFIAST = EPUBcfi.Parser.parse(decodedCFI);
        var indirectionNode;
        var indirectionStepNum;
        
        // Rationale: Since the correct content document for this CFI is already being passed, we can skip to the beginning 
        //   of the indirection step that referenced the content document.
        // Note: This assumes that indirection steps and index steps conform to an interface: an object with stepLength, idAssertion
        indirectionStepNum = this.getFirstIndirectionStepNum(CFIAST);
        indirectionNode = CFIAST.cfiString.localPath.steps[indirectionStepNum];
        indirectionNode.type = "indexStep";

        // Interpret the rest of the steps
        $currElement = this.interpretLocalPath(CFIAST.cfiString, indirectionStepNum, $("html", contentDocument), classBlacklist, elementBlacklist, idBlacklist);

        // Return the element at the end of the CFI
        return $currElement;
    },

    // Description: This method allows a "partial" CFI to be used to reference a target in a content document, without a 
    //   package document CFI component. 
    // Arguments: {
    //     contentDocumentCFI : This is a partial CFI that represents a path in a content document only. This partial must be 
    //        syntactically valid, even though it references a path starting at the top of a content document (which is a CFI that
    //        that has no defined meaning in the spec.)
    //     contentDocument : A DOM representation of the content document to which the partial CFI refers. 
    // }
    // Rationale: This method exists to meet the requirements of the Readium-SDK and should be used with care
    getTargetElementWithPartialCFI : function (contentDocumentCFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist) {

        var decodedCFI = decodeURI(contentDocumentCFI);
        var CFIAST = EPUBcfi.Parser.parse(decodedCFI);
        var indirectionNode;
        
        // Interpret the path node 
        var $currElement = this.interpretIndexStepNode(CFIAST.cfiString.path, $("html", contentDocument), classBlacklist, elementBlacklist, idBlacklist);

        // Interpret the rest of the steps
        $currElement = this.interpretLocalPath(CFIAST.cfiString, 0, $currElement, classBlacklist, elementBlacklist, idBlacklist);

        // Return the element at the end of the CFI
        return $currElement;        
    },

    // Description: This method allows a "partial" CFI to be used, with a content document, to return the text node and offset 
    //    referenced by the partial CFI.
    // Arguments: {
    //     contentDocumentCFI : This is a partial CFI that represents a path in a content document only. This partial must be 
    //        syntactically valid, even though it references a path starting at the top of a content document (which is a CFI that
    //        that has no defined meaning in the spec.)
    //     contentDocument : A DOM representation of the content document to which the partial CFI refers. 
    // }
    // Rationale: This method exists to meet the requirements of the Readium-SDK and should be used with care
    getTextTerminusInfoWithPartialCFI : function (contentDocumentCFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist) {

        var decodedCFI = decodeURI(contentDocumentCFI);
        var CFIAST = EPUBcfi.Parser.parse(decodedCFI);
        var indirectionNode;
        var textOffset;
        
        // Interpret the path node 
        var $currElement = this.interpretIndexStepNode(CFIAST.cfiString.path, $("html", contentDocument), classBlacklist, elementBlacklist, idBlacklist);

        // Interpret the rest of the steps
        $currElement = this.interpretLocalPath(CFIAST.cfiString, 0, $currElement, classBlacklist, elementBlacklist, idBlacklist);

        // Return the element at the end of the CFI
        textOffset = parseInt(CFIAST.cfiString.localPath.termStep.offsetValue);
        return { textNode : $currElement,
                 textOffset : textOffset
            };
    },

    // ------------------------------------------------------------------------------------ //
    //  "PRIVATE" HELPERS                                                                   //
    // ------------------------------------------------------------------------------------ //

    getFirstIndirectionStepNum : function (CFIAST) {

        // Find the first indirection step in the local path; follow it like a regular step, as the step in the content document it 
        //   references is already loaded and has been passed to this method
        var stepNum = 0;
        for (stepNum; stepNum <= CFIAST.cfiString.localPath.steps.length - 1 ; stepNum++) {
        
            nextStepNode = CFIAST.cfiString.localPath.steps[stepNum];
            if (nextStepNode.type === "indirectionStep") {
                return stepNum;
            }
        }
    },

    // REFACTORING CANDIDATE: cfiString node and start step num could be merged into one argument, by simply passing the 
    //   starting step. 
    interpretLocalPath : function (cfiStringNode, startStepNum, $currElement, classBlacklist, elementBlacklist, idBlacklist) {

        var stepNum = startStepNum;
        var nextStepNode;
        for (stepNum; stepNum <= cfiStringNode.localPath.steps.length - 1 ; stepNum++) {
        
            nextStepNode = cfiStringNode.localPath.steps[stepNum];
            if (nextStepNode.type === "indexStep") {

                $currElement = this.interpretIndexStepNode(nextStepNode, $currElement, classBlacklist, elementBlacklist, idBlacklist);
            }
            else if (nextStepNode.type === "indirectionStep") {

                $currElement = this.interpretIndirectionStepNode(nextStepNode, $currElement, classBlacklist, elementBlacklist, idBlacklist);
            }
        }

        return $currElement;
    },

    interpretIndexStepNode : function (indexStepNode, $currElement, classBlacklist, elementBlacklist, idBlacklist) {

        // Check node type; throw error if wrong type
        if (indexStepNode === undefined || indexStepNode.type !== "indexStep") {

            throw EPUBcfi.NodeTypeError(indexStepNode, "expected index step node");
        }

        // Index step
        var $stepTarget = EPUBcfi.CFIInstructions.getNextNode(indexStepNode.stepLength, $currElement, classBlacklist, elementBlacklist, idBlacklist);

        // Check the id assertion, if it exists
        if (indexStepNode.idAssertion) {

            if (!EPUBcfi.CFIInstructions.targetIdMatchesIdAssertion($stepTarget, indexStepNode.idAssertion)) {

                throw EPUBcfi.CFIAssertionError(indexStepNode.idAssertion, $stepTarget.attr('id'), "Id assertion failed");
            }
        }

        return $stepTarget;
    },

    interpretIndirectionStepNode : function (indirectionStepNode, $currElement, classBlacklist, elementBlacklist, idBlacklist) {

        // Check node type; throw error if wrong type
        if (indirectionStepNode === undefined || indirectionStepNode.type !== "indirectionStep") {

            throw EPUBcfi.NodeTypeError(indirectionStepNode, "expected indirection step node");
        }

        // Indirection step
        var $stepTarget = EPUBcfi.CFIInstructions.followIndirectionStep(
            indirectionStepNode.stepLength, 
            $currElement, 
            classBlacklist, 
            elementBlacklist);

        // Check the id assertion, if it exists
        if (indirectionStepNode.idAssertion) {

            if (!EPUBcfi.CFIInstructions.targetIdMatchesIdAssertion($stepTarget, indirectionStepNode.idAssertion)) {

                throw EPUBcfi.CFIAssertionError(indirectionStepNode.idAssertion, $stepTarget.attr('id'), "Id assertion failed");
            }
        }

        return $stepTarget;
    },

    // REFACTORING CANDIDATE: The logic here assumes that a user will always want to use this terminus
    //   to inject content into the found node. This should be changed to be more flexible.
    interpretTextTerminusNode : function (terminusNode, $currElement, elementToInject) {

        if (terminusNode === undefined || terminusNode.type !== "textTerminus") {

            throw EPUBcfi.NodeTypeError(terminusNode, "expected text terminus node");
        }

        var $elementInjectedInto = EPUBcfi.CFIInstructions.textTermination(
            $currElement, 
            terminusNode.offsetValue, 
            elementToInject);

        return $elementInjectedInto;
    }
};

    // Description: This is a set of runtime errors that the CFI interpreter can throw. 
// Rationale: These error types extend the basic javascript error object so error things like the stack trace are 
//   included with the runtime errors. 

// REFACTORING CANDIDATE: This type of error may not be required in the long run. The parser should catch any syntax errors, 
//   provided it is error-free, and as such, the AST should never really have any node type errors, which are essentially errors
//   in the structure of the AST. This error should probably be refactored out when the grammar and interpreter are more stable.
EPUBcfi.NodeTypeError = function (node, message) {

    function NodeTypeError () {

        this.node = node;
    }

    NodeTypeError.prototype = new Error(message);
    NodeTypeError.constructor = NodeTypeError;

    return new NodeTypeError();
};

// REFACTORING CANDIDATE: Might make sense to include some more specifics about the out-of-rangeyness.
EPUBcfi.OutOfRangeError = function (targetIndex, maxIndex, message) {

    function OutOfRangeError () {

        this.targetIndex = targetIndex;
        this.maxIndex = maxIndex;
    }

    OutOfRangeError.prototype = new Error(message);
    OutOfRangeError.constructor = OutOfRangeError()

    return new OutOfRangeError();
};

// REFACTORING CANDIDATE: This is a bit too general to be useful. When I have a better understanding of the type of errors
//   that can occur with the various terminus conditions, it'll make more sense to revisit this. 
EPUBcfi.TerminusError = function (terminusType, terminusCondition, message) {

    function TerminusError () {

        this.terminusType = terminusType;
        this.terminusCondition = terminusCondition;
    }

    TerminusError.prototype = new Error(message);
    TerminusError.constructor = TerminusError();

    return new TerminusError();
};

EPUBcfi.CFIAssertionError = function (expectedAssertion, targetElementAssertion, message) {

    function CFIAssertionError () {

        this.expectedAssertion = expectedAssertion;
        this.targetElementAssertion = targetElementAssertion;
    }

    CFIAssertionError.prototype = new Error(message);
    CFIAssertionError.constructor = CFIAssertionError();

    return new CFIAssertionError();
};


    EPUBcfi.Generator = {

    // ------------------------------------------------------------------------------------ //
    //  "PUBLIC" METHODS (THE API)                                                          //
    // ------------------------------------------------------------------------------------ //

    // Description: Generates a character offset CFI 
    // Arguments: The text node that contains the offset referenced by the cfi, the offset value, the name of the 
    //   content document that contains the text node, the package document for this EPUB.
    generateCharacterOffsetCFIComponent : function (startTextNode, characterOffset, classBlacklist, elementBlacklist, idBlacklist) {

        var textNodeStep;
        var contentDocCFI;
        var $itemRefStartNode;
        var packageDocCFI;

        this.validateStartTextNode(startTextNode, characterOffset);

        // Create the text node step
        textNodeStep = this.createCFITextNodeStep($(startTextNode), characterOffset, classBlacklist, elementBlacklist, idBlacklist);

        // Call the recursive method to create all the steps up to the head element of the content document (the "html" element)
        contentDocCFI = this.createCFIElementSteps($(startTextNode).parent(), "html", classBlacklist, elementBlacklist, idBlacklist) + textNodeStep;
        return contentDocCFI.substring(1, contentDocCFI.length);
    },

    generateElementCFIComponent : function (startElement, classBlacklist, elementBlacklist, idBlacklist) {

        var contentDocCFI;
        var $itemRefStartNode;
        var packageDocCFI;

        this.validateStartElement(startElement);

        // Call the recursive method to create all the steps up to the head element of the content document (the "html" element)
        contentDocCFI = this.createCFIElementSteps($(startElement), "html", classBlacklist, elementBlacklist, idBlacklist);

        // Remove the ! 
        return contentDocCFI.substring(1, contentDocCFI.length);
    },

    generatePackageDocumentCFIComponent : function (contentDocumentName, packageDocument, classBlacklist, elementBlacklist, idBlacklist) {

        this.validateContentDocumentName(contentDocumentName);
        this.validatePackageDocument(packageDocument, contentDocumentName);

        // Get the start node (itemref element) that references the content document
        $itemRefStartNode = $("itemref[idref='" + contentDocumentName + "']", $(packageDocument));

        // Create the steps up to the top element of the package document (the "package" element)
        packageDocCFIComponent = this.createCFIElementSteps($itemRefStartNode, "package", classBlacklist, elementBlacklist, idBlacklist);

        // Append an !; this assumes that a CFI content document CFI component will be appended at some point
        return packageDocCFIComponent + "!";
    },

    generateCompleteCFI : function (packageDocumentCFIComponent, contentDocumentCFIComponent) {

        return "epubcfi(" + packageDocumentCFIComponent + contentDocumentCFIComponent + ")";  
    },

    // ------------------------------------------------------------------------------------ //
    //  "PRIVATE" HELPERS                                                                   //
    // ------------------------------------------------------------------------------------ //

    validateStartTextNode : function (startTextNode, characterOffset) {
        
        // Check that the text node to start from IS a text node
        if (!startTextNode) {
            throw new EPUBcfi.NodeTypeError(startTextNode, "Cannot generate a character offset from a starting point that is not a text node");
        } else if (startTextNode.nodeType != 3) {
            throw new EPUBcfi.NodeTypeError(startTextNode, "Cannot generate a character offset from a starting point that is not a text node");
        }

        // Check that the character offset is within a valid range for the text node supplied
        if (characterOffset < 0) {
            throw new EPUBcfi.OutOfRangeError(characterOffset, 0, "Character offset cannot be less than 0");
        }
        else if (characterOffset > startTextNode.nodeValue.length) {
            throw new EPUBcfi.OutOfRangeError(characterOffset, startTextNode.nodeValue.length - 1, "character offset cannot be greater than the length of the text node");
        }
    },

    validateStartElement : function (startElement) {

        if (!startElement) {
            throw new EPUBcfi.NodeTypeError(startElement, "CFI target element is undefined");
        }

        if (!(startElement.nodeType && startElement.nodeType === 1)) {
            throw new EPUBcfi.NodeTypeError(startElement, "CFI target element is not an HTML element");
        }
    },

    validateContentDocumentName : function (contentDocumentName) {

        // Check that the idref for the content document has been provided
        if (!contentDocumentName) {
            throw new Error("The idref for the content document, as found in the spine, must be supplied");
        }
    },

    validatePackageDocument : function (packageDocument, contentDocumentName) {
        
        // Check that the package document is non-empty and contains an itemref element for the supplied idref
        if (!packageDocument) {
            throw new Error("A package document must be supplied to generate a CFI");
        }
        else if ($($("itemref[idref='" + contentDocumentName + "']", packageDocument)[0]).length === 0) {
            throw new Error("The idref of the content document could not be found in the spine");
        }
    },

    // Description: Creates a CFI terminating step, to a text node, with a character offset
    // REFACTORING CANDIDATE: Some of the parts of this method could be refactored into their own methods
    createCFITextNodeStep : function ($startTextNode, characterOffset, classBlacklist, elementBlacklist, idBlacklist) {

        var $parentNode;
        var $contentsExcludingMarkers;
        var CFIIndex;
        var indexOfTextNode;
        var preAssertion;
        var preAssertionStartIndex;
        var textLength;
        var postAssertion;
        var postAssertionEndIndex;

        // Find text node position in the set of child elements, ignoring any blacklisted elements 
        $parentNode = $startTextNode.parent();
        $contentsExcludingMarkers = EPUBcfi.CFIInstructions.applyBlacklist($parentNode.contents(), classBlacklist, elementBlacklist, idBlacklist);

        // Find the text node index in the parent list, inferring nodes that were originally a single text node
        var prevNodeWasTextNode;
        var indexOfFirstInSequence;

      /*
        Notes about blinkbox mods
        This particular function was not correctly generating CFI indexes for text nodes
        The CFI spec states that:
          - elements will always have an even index
          - text nodes will always have an odd index

          examples :
            Node        CFI index
            ---------------------
         Case 1 :
            <sup>         /2
            text node     /3
            <sup>         /4
            text node     /5
            <sup>         /6
            text ndoe     /7
           ---------------------
         Case 2:
           <p>
              text node   /1
           </p>
           ---------------------
         Case 3:
           <p>
             text node    /1
             text node    character offsets from /1
             text node    character offsets from /1
           </p>
       */


        CFIIndex = 0;  // *** blinkbox mod *** this index represents the final index to the target text node

        $.each($contentsExcludingMarkers,
            function (index) {

                // If this is a text node, check if it matches and return the current index
                if (this.nodeType === 3) {
                  // This is a text node
                  if (!prevNodeWasTextNode) { // *** blinkbox mod *** don't increment index if previous node was a text node (see Case 3 above)
                    CFIIndex++;               // *** blinkbox mod ***
                  }                           // *** blinkbox mod ***
                  if (this === $startTextNode[0]) {

                        // Set index as the first in the adjacent sequence of text nodes, or as the index of the current node if this 
                        //   node is a standard one sandwiched between two element nodes. 
                        if (prevNodeWasTextNode) {
                            indexOfTextNode = indexOfFirstInSequence;
                        }
                        else {
                            indexOfTextNode = index;
                        }
                        // Break out of .each loop
                        return false; 
                    }

                    // Save this index as the first in sequence of adjacent text nodes, if it is not already set by this point
                    prevNodeWasTextNode = true;
                    if (!indexOfFirstInSequence) {
                        indexOfFirstInSequence = index;
                    }
                }
                else {
                  	// This is a not a text node
                    indexOfFirstInSequence = undefined;
                    CFIIndex = !prevNodeWasTextNode ? CFIIndex + 2 : CFIIndex + 1; // *** blinkbox mod *** if the first node is an element, start CFIndex at 2, else increment
										prevNodeWasTextNode = false;
								}
            }
        );

        // Convert the text node index to a CFI odd-integer representation
        // commented out *** blinkbox mod ***  -> CFIIndex = (indexOfTextNode * 2) + 1;  this is how the CFI index was being (incorrectly) calculated

        // TODO: text assertions are not in the grammar yet, I think, or they're just causing problems. This has
        //   been temporarily removed. 

        // Add pre- and post- text assertions
        // preAssertionStartIndex = (characterOffset - 3 >= 0) ? characterOffset - 3 : 0;
        // preAssertion = $startTextNode[0].nodeValue.substring(preAssertionStartIndex, characterOffset);

        // textLength = $startTextNode[0].nodeValue.length;
        // postAssertionEndIndex = (characterOffset + 3 <= textLength) ? characterOffset + 3 : textLength;
        // postAssertion = $startTextNode[0].nodeValue.substring(characterOffset, postAssertionEndIndex);

        // Gotta infer the correct character offset, as well

        // Return the constructed CFI text node step
        return "/" + CFIIndex + ":" + characterOffset;
         // + "[" + preAssertion + "," + postAssertion + "]";
    },

    // Description: A set of adjacent text nodes can be inferred to have been a single text node in the original document. As such, 
    //   if the character offset is specified for one of the adjacent text nodes, the true offset for the original node must be
    //   inferred.
    findOriginalTextNodeCharOffset : function ($startTextNode, specifiedCharacterOffset, classBlacklist, elementBlacklist, idBlacklist) {

        var $parentNode;
        var $contentsExcludingMarkers;
        var textLength;
        
        // Find text node position in the set of child elements, ignoring any cfi markers 
        $parentNode = $startTextNode.parent();
        $contentsExcludingMarkers = EPUBcfi.CFIInstructions.applyBlacklist($parentNode.contents(), classBlacklist, elementBlacklist, idBlacklist);

        // Find the text node number in the list, inferring nodes that were originally a single text node
        var prevNodeWasTextNode;
        var originalCharOffset = -1; // So the character offset is a 0-based index; we'll be adding lengths of text nodes to this number
        $.each($contentsExcludingMarkers, 
            function (index) {

                // If this is a text node, check if it matches and return the current index
                if (this.nodeType === 3) {

                    if (this === $startTextNode[0]) {

                        if (prevNodeWasTextNode) {
                            originalCharOffset = originalCharOffset + specifiedCharacterOffset;
                        }
                        else {
                            originalCharOffset = specifiedCharacterOffset;
                        }

                        return false; // Break out of .each loop
                    }
                    else {

                        originalCharOffset = originalCharOffset + this.length;
                    }

                    // save this index as the first in sequence of adjacent text nodes, if not set
                    prevNodeWasTextNode = true;
                }
                // This node is not a text node
                else {
                    prevNodeWasTextNode = false;
                }
            }
        );

        return originalCharOffset;
    },

    createCFIElementSteps : function ($currNode, topLevelElement, classBlacklist, elementBlacklist, idBlacklist) {

        var $blacklistExcluded;
        var $parentNode;
        var currNodePosition;
        var CFIPosition;
        var idAssertion;
        var elementStep; 

        // Find position of current node in parent list
        $blacklistExcluded = EPUBcfi.CFIInstructions.applyBlacklist($currNode.parent().children(), classBlacklist, elementBlacklist, idBlacklist);
        $.each($blacklistExcluded, 
            function (index, value) {

                if (this === $currNode[0]) {

                    currNodePosition = index;

                    // Break loop
                    return false;
                }
        });

        // Convert position to the CFI even-integer representation
        CFIPosition = (currNodePosition + 1) * 2;

        // Create CFI step with id assertion, if the element has an id
        if ($currNode.attr("id")) {
            elementStep = "/" + CFIPosition + "[" + $currNode.attr("id") + "]";
        }
        else {
            elementStep = "/" + CFIPosition;
        }

        // If a parent is an html element return the (last) step for this content document, otherwise, continue.
        //   Also need to check if the current node is the top-level element. This can occur if the start node is also the
        //   top level element.
        $parentNode = $currNode.parent();
        if ($parentNode.is(topLevelElement) || $currNode.is(topLevelElement)) {
            
            // If the top level node is a type from which an indirection step, add an indirection step character (!)
            // REFACTORING CANDIDATE: It is possible that this should be changed to: if (topLevelElement = 'package') do
            //   not return an indirection character. Every other type of top-level element may require an indirection
            //   step to navigate to, thus requiring that ! is always prepended. 
            if (topLevelElement === 'html') {
                return "!" + elementStep;
            }
            else {
                return elementStep;
            }
        }
        else {
            return this.createCFIElementSteps($parentNode, topLevelElement, classBlacklist, elementBlacklist, idBlacklist) + elementStep;
        }
    }
};

    if (global.EPUBcfi) {

        throw new Error('The EPUB cfi library has already been defined');
    }
    else {

        global.EPUBcfi = EPUBcfi;
    }
}) (typeof window === 'undefined' ? this : window);

/*
 * Bugsense JavaScript SDK v1.1.1
 * http://bugsense.com/
 *
 * Copyright 2013 Splunk Inc.
 *
 * Date: 2013-11-18
 */
var bugsense;

(function ( root, factory ) {
	if ( typeof define === 'function' && define.amd ) {
		// AMD. Register as an anonymous module.
		define(function () {
			// Also create a global in case some scripts
			// that are loaded still are looking for
			// a global even when an AMD loader is in use.
			return ( root.Bugsense = factory() );
		});
	} else {
		// Browser globals
		root.Bugsense = factory();
	}
}( this, function () {

	/**
	 * Simple extend() implementation
	 * @param  {Object} original The object to extend
	 * @param  {Object} extra    The properties to extend with
	 * @return {Object}          The extended original object
	 */
	var extend = function extend ( original, extra ) {
		return Object.keys( extra ).forEach( function ( key ) { original[ key ] = extra[ key ]; } );
	};

	// BEGIN - Extracted from Zepto
	var escape = encodeURIComponent;

	var isObject = function isObject ( instance ) {
		return instance instanceof Object;
	};

	var isArray = function isArray ( instance ) {
		return instance instanceof Array;
	};

	var isValidKeyValue = function isValidKeyValue ( instance ) {
		return ( typeof(instance) == 'string' || typeof(instance) == 'number' || typeof(instance) == 'boolean' );
	};

	/**
	 * Simple forEach, implements jQuery/Zepto api, sort of, and most likely breaks with arrays: LOL
	 * @param  {Object} obj      To be iterated
	 * @param  {Object} iterator Iterator function
	 */
	var forEach = function forEach ( obj, iterator ) {
		Array.prototype.forEach.call( Object.keys( obj ), function ( key ) {
			iterator( key, obj[ key ] );
		} );
	};

	var serialize = function serialize ( params, obj, traditional, scope ) {
		var array = isArray( obj );

		forEach( obj, function ( key, value ) {
			if ( scope ) { key = traditional ? scope : scope + '[' + (array ? '' : key) + ']'; }

			// handle data in serializeArray() format
			if ( !scope && array ) {
				params.add( value.name, value.value );
				// recurse into nested objects
			} else if ( traditional ? isArray( value ) : isObject( value ) ) {
				serialize( params, value, traditional, key );
			} else {
				params.add( key, value );
			}
		});
	};

	var param = function param ( obj, traditional ) {
		var params = [];
		params.add = function( k, v ){ this.push( escape( k ) + '=' + escape( v ) ); };
		serialize( params, obj, traditional );
		return params.join( '&' ).replace( /%20/g, '+' );
	};
	// END - Extracted from Zepto


	var guid_generator = function GUIDGenerator() {
		var S4 = function () {
			return Math.floor(
				Math.random() * 0x10000 /* 65536 */
			).toString(16);
		};

		return (
			S4() + S4() + "-" +
				S4() + "-" +
				S4() + "-" +
				S4() + "-" +
				S4() + S4() + S4()
			);
	}


	/**
	 * Constructor for the Bugsense instance
	 * @param {Object} config Overrides for the default config, use to specify api key
	 */
	var Bugsense = function ( config ) {
		extend(this.config, config);
		this.config.winjs = typeof (WinJS) !== 'undefined';
		this.extraData = {};
		this.breadcrumbs = [];

		bugsense = this;
		if ( typeof(this.config.context.onerror) !== 'undefined' && !this.config.disableOnError )
			this.config.context.onerror = bugsense.onerror;
		// WINJS
		if ( this.config.winjs ) {
			WinJS.Promise.onerror = bugsense.onpremiseerror;
			var p = Windows.ApplicationModel.Package.current.id.version;
			this.config.appversion = [p.major, p.minor, p.build, p.revision].join('.');
			this.send_cached_report_if_any();
			// Create unique device id
			var localSettings = Windows.Storage.ApplicationData.current.localSettings;
			var guid = localSettings['guid'];
			if (!guid) {
				guid = guid_generator();
				localSettings['guid'] = guid;
			}
			this.config.guid = guid;
		}
		// CORDOVA

		return this;
	};

	// Default config
	Bugsense.prototype.config = {
		apiKey     : 'FOOBAR',
		url        : 'https://www.bugsense.com/api/errors',
		//url      : 'https://csh-bugsense.fwd.wf/api/errors',
		pingUrl    : 'http://ticks2.bugsense.com/api/ticks',
		appversion : null,
		popup      : false, // unless WinJS
		callback   : null,
		context: window,
		winjs: null,
		message: null
	};

	/**
	 * Add extra data (meta data) to be sent upon uncaught exception
	 * @params {String} key      Key
	 * @params {String} value    Value
	 */
	Bugsense.prototype.addExtraData = function bugsenseAddExtraData ( key, value ) {
		if ( isValidKeyValue( key ) && isValidKeyValue( value ) ) {
			this.extraData[ key ] = value;
		}
	}

	/**
	 * Remove a key value pair from extra data
	 * @params {String} key      Key
	 */
	Bugsense.prototype.removeExtraData = function bugsenseRemoveExtraData ( key ) {
		delete this.extraData[ key ];
	}

	/**
	 * Clear extra data
	 */
	Bugsense.prototype.clearExtraData = function bugsenseClearExtraData () {
		this.extraData = {};
	}

	/**
	 * Leave a breadcrump
	 * @params {String} breadcrumb  Breadcrumb
	 */
	Bugsense.prototype.leaveBreadcrumb = function bugsenseLeaveBreadcrumb ( breadcrumb ) {
		if ( isValidKeyValue( breadcrumb ) ) {
			if ( this.breadcrumbs.length + 1 == 16 ) {
				this.breadcrumbs = this.breadcrumbs.slice( 1 );
			}
			this.breadcrumbs.push( breadcrumb );
		}
	}

	/**
	 * Clear breadcrumbs
	 */
	Bugsense.prototype.clearBreadcrumbs = function bugsenseClearBreadcrumbs () {
		this.breadcrumbs = []
	}

	/**
	 * Kill bugsense and the app. Force exit
	 */
	Bugsense.prototype._die = function bugsenseDie() {
		throw 'BugSense exited';
	}

	/**
	 * Handles the response from the Bugsense API endpoint
	 * @param  {Object} data       Bugsense response object
	 * @param  {String} textStatus Response http status code
	 * @param  {Object} XHR        XHR object
	 */
	Bugsense.prototype.successHandler = function bugsenseSuccessHandler(request) {
		// Die
		function _die () { throw 'BugSense exited'; }
		// TODO if WinJS show notifications to user
		if (request.target && request.target.readyState != 4) { return; }
		if (request.target && request.target.status != 200 && bugsense.config.winjs) {
			return false;
		}

		// some console.log implementations don't support multiple parameters, guess it's okay in this case to concatenate
		if ('console' in window) {
			console.log('logged 1 error to Bugsense, status: ' + request.target.responseText);
		}
		if (bugsense.config.winjs) {
			if (request.target.responseText !== undefined && request.target.responseText.indexOf('url') > 0) {
				var response = JSON.parse(request.target.responseText);
				// Display fix notification if set

				var md = new Windows.UI.Popups.MessageDialog(response.data.tickerText);
				var result, resultOptions = ['Update', 'Cancel'];
				var cmd;

				for (var i = 0; i < resultOptions.length; i++) {
					cmd = new Windows.UI.Popups.UICommand();
					cmd.label = resultOptions[i];
					// Style update
					cmd.invoked = function (c) {
						result = c.label;
					}
					md.commands.append(cmd);
				}

				md.showAsync().then(function (c) {
					if (c.label == 'Update') {
						var uri = Windows.Foundation.Uri(response.data.url);
						Windows.System.Launcher.launchUriAsync(uri);
					}
					return c.label;
				}).done(function complete() { window.bugsense._die(); });
				// Show popup message is set

			} else if (request.target.responseText.length > 0 && request.target.responseText.indexOf('url') < 0) { // NOT OPTIONS
				if (window.bugsense.config.message !== null) {
					var md = new Windows.UI.Popups.MessageDialog(window.bugsense.config.message);
					var result, resultOptions = ['OK'];
					var cmd;

					for (var i = 0; i < resultOptions.length; i++) {
						cmd = new Windows.UI.Popups.UICommand();
						cmd.label = resultOptions[i];
						cmd.invoked = function (c) {
							result = c.label;
						}
						md.commands.append(cmd);
					}

					md.showAsync().then(function (c) {
						return c.label;
					}).done(function complete() { window.bugsense._die(); });
				} else {
					// Just die!
					window.bugsense._die();
				}
			}
		}

	};

	/**
	 * Returns the Bugsense api url, with a cacheBuster argument
	 * @return {String} Bugsense API URL endpoint
	 */
	Bugsense.prototype.getPostURL = function bugsenseGetPostURL () {
		return Bugsense.prototype.config.url + '?cacheBuster=' + ( new Date() ).getTime();
	};

	/**
	 * Parses a raw Error object
	 * @param  {Object} error A raw Error object - e.g.: as sent from try/catch
	 * @return {Object}       An object containing the parsed data as its properties
	 */
	Bugsense.prototype.parseError = function bugsenseParseError ( error ) {
		var parsedError = {}
		// Firefox
		if ( navigator.userAgent.toLowerCase().indexOf('firefox') > -1 ){
			parsedError = {
				message: error.message,
				url: window.location.href,
				line: error.lineNumber,
				stack: error.stack,
				type: error.name
			}
			// Unhandled WinJS
		} else if ( this.config.winjs === true && typeof( error.stack ) === 'undefined' ) {
			parsedError = {
				message: error.detail.errorMessage,
				url: error.detail.errorUrl,
				line: error.detail.errorLine,
				stack: ( error.detail.stack === undefined ) ? error.detail.errorMessage : error.detail.stack,
				type: error.detail.errorCode
			};
			// Handled WinJS
		} else if (this.config.winjs === true && typeof( error.stack ) !== 'undefined') {
			var s = error.stack;
			var tmp = s.substr(s.indexOf('(') + 1, s.indexOf(')') - s.indexOf('(') - 1).split(':');
			parsedError = {
				message: error.message,
				url: tmp[0] + ':' + tmp[1],
				line:tmp[2] ,
				stack: error.stack,
				type: error.stack.split(':')[0],
				handled: true
			};
			// Webkit
		} else {
			// If .stack is not available
			try {
				var where_parts = error.stack.split( '\n' ).slice(1)[0].match( /\s+at\s.*(\/.*\..*|<anonymous>:\d*:\d*)/ );
			} catch ( error ) {
				error.stack = error.message;
			}
			parsedError = {
				message: [ error.name, error.message ].join( ': ' ),
				url: where_parts ? where_parts[ 1 ].split( ':' )[ 0 ].replace("/","") : '',
				line: where_parts ? where_parts[ 1 ].split( ':' )[ 1 ] : '',
				stack: error.stack,
				type: error.name
			};
		}

		if ( parsedError.stack == null || ( typeof( parsedError.stack ) == 'string' && parsedError.stack.length == 0 ) ) {
			parsedError.stack = parsedError.message;
		}

		return parsedError;
	};

	/**
	 * Generates an object containing the exception data, compliant with Bugsense's API
	 * @param  {String} exception   The error message ( also accepts Error Object, will be normalized )
	 *                              e.g.: "Uncaught ReferenceError: ben is not defined"
	 * @param  {String} url         The originating url
	 *                              e.g.: "http://lmjabreu.local:8002/assets/js/main.js"
	 * @param  {Number} line        The line number
	 *                              e.g.: "12"
	 * @param  {Object} custom_Data An object containing extra debugging data
	 * @return {Object}           Bugsense API-compliant exception object
	 */
	Bugsense.prototype.generateExceptionData = function bugsenseGenerateExceptionData ( message, url, line, stack, custom_data ) {
		if ( typeof( message ) != "string" ) {
			message = message.toString()
		}

		var s = window.navigator.userAgent;
		var connection_type = 'unknown';
		if (this.config.winjs) {
			try {
				connection_type = Windows.Networking.Connectivity.NetworkInformation.getInternetConnectionProfile().profileName;
			} catch (exception) {
				connection_type = 'Offline';
			}
		} else if ( typeof window.navigator.network !== 'undefined' ) {
			connection_type = window.navigator.network.connection.type;
		}

		var data = {
			// information about the bugsense client
			client: {
				// Obligatory
				'name'    : 'bugsense-js',
				// Optional
				'version' : '1.1'
			},
			// Optional
			// details & custom data about the exception including url, request, response,
			request: {
				'custom_data' : custom_data
			},
			// basics about the exception
			exception: {
				// Obligatory
				'message'     : message,
				'where'       : [ url, line ].join( ':' ),
				'klass'       : message.split( ':' )[ 0 ],
				'backtrace'   : ( typeof(stack) === 'undefined' ) ? message : stack,
				'breadcrumbs': this.breadcrumbs
			},
			// basic data ( required )
			application_environment: {
				// Obligatory
				'phone'              : window.navigator.platform,
				'appver'             : ( this.config.appversion || 'unknown' ),
				'appname'            : ( this.config.appname || 'unknown' ),
				'osver'              : ( typeof window.device !== 'undefined' ) ? window.device.version : s.substr(s.indexOf('; ')+2,s.length).replace(')',';').split(';')[0] || 'unknown' ,
				// Optional
				'connection_type'    : connection_type,
				'user_agent'         : window.navigator.userAgent,
				'cordova'            : ( typeof window.device !== 'undefined' ) ? window.device.cordova : 'unknown',
				'device_name'        : ( typeof window.device !== 'undefined' ) ? window.device.name : 'unknown',
				'log_data'           : this.extraData
			}
		};

		if (this.config.winjs) {
			// Extra vars for Windows apps
			data.application_environment.cpuClass = window.navigator.cpuClass;
			data.application_environment.osver = window.navigator.userAgent.split(';')[2];
			data.application_environment.languages = window.navigator.systemLanguage;
			data.application_environment.locale = window.navigator.userLanguage;
			data.application_environment.is_trial = Windows.ApplicationModel.Store.CurrentApp.licenseInformation.isTrial;
			data.application_environment.is_active = Windows.ApplicationModel.Store.CurrentApp.licenseInformation.isActive;
			data.application_environment.uid = this.config.guid;
			if (typeof (custom_data) !== 'undefined') {
				if ( typeof(custom_data.handled) !== 'undefined' ){
					data.exception.handled = 0;
				}
			}
		}

		return data;
	};

	/**
	 * Returns true for Error objects
	 * @param  {Object} exception The object to test
	 * @return {Boolean}           True for Error objects - [object Error]
	 */
	Bugsense.prototype.testException = function bugsenseTestException(exception) {
		// unhandled winjs exceptions
		if (this.config.winjs === true && typeof(exception.detail) !== 'undefined')
			return exception.type === "error";
		// catches handled winjs exceptions as well
		return Object.prototype.toString.call(exception) === '[object Error]';
	};

	/**
	 * Returns true if it is an exeption throwed by BugSense
	 * @param {Object} exception
	 */
	Bugsense.prototype.isBugsenseException = function bugsenseIsBugsenseException(exception) {
		return this.config.winjs && this.testException(exception) && exception.detail.errorMessage === "BugSense exited";
	}

	/**
	 * Notify Bugsense about an exception
	 * @param  {String} exception   The error message ( also accepts Error Object, will be normalized )
	 * @param  {String} url         The originating url
	 * @param  {String} line        The line number
	 * @param  {Object} custom_data Custom data to send over to Bugsense
	 */
	Bugsense.prototype.notify = function bugsenseNotify(exception, url, line, column, custom_data) {
		var stack;
		// Prints exception stack to console before the exception is handled by Bugsense
		if (typeof(column) === 'object') {
			custom_data = column;
		}
		if (window.console && window.console.error) {
			console.error(exception, url+':'+line);
		}
		// Handle cases where only Error object and custom data are sent - url will be the custom_data
		if ( typeof(url) === 'object' && this.testException( exception ) ) { custom_data = url; url = undefined; }

		// If the exception is the full Error object, extract what we want from it
		if ( this.testException( exception ) ) {
			var parsedError = this.parseError( exception );

			message = [ parsedError.type, parsedError.message ].join( ':' );
			url = parsedError.url;
			line = parsedError.line;
			stack = parsedError.stack;
			if (typeof (parsedError.handled) !== 'undefined') {
				if (typeof (custom_data) !== 'object') custom_data = {};
				custom_data.handled = 0;
			}
		} else {
			message = exception;
		}

		var data = this.generateExceptionData( message, url, line, stack, custom_data );

		// Send the data over to Bugsense
		var xmlhttp = new XMLHttpRequest();
		xmlhttp.open( 'POST', this.getPostURL(), true );
		xmlhttp.setRequestHeader( 'X-BugSense-Api-Key', this.config.apiKey );
		xmlhttp.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
		xmlhttp.onerror = function (a) {
			if (bugsense.config.winjs) {
				WinJS.Application.local.writeText('CachedCrashReport', JSON.stringify(data)).done(
					function complete() { console.log('written'); window.bugsense._die() }
				);
			}
		}
		if (!(custom_data instanceof Object && custom_data.handled == 0))
			xmlhttp.onreadystatechange = this.successHandler;

		xmlhttp.send(param({ data: JSON.stringify(data) }));

		return true;
	};

	/**
	 * Send cashed crash report
	 */
	Bugsense.prototype.send_cached_report_if_any = function bugsenseSendCachedReport() {
		var local = WinJS.Application.local;
		local.exists('CachedCrashReport').then(function (exists) {
			if (exists) {
				local.readText('CachedCrashReport').then(function (strdata) {
					var data = JSON.parse(strdata);
					// Send the data over to Bugsense
					var xmlhttp = new XMLHttpRequest();
					xmlhttp.open('POST', window.bugsense.getPostURL(), true);
					xmlhttp.setRequestHeader('X-BugSense-Api-Key', window.bugsense.config.apiKey);
					xmlhttp.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
					xmlhttp.onreadystatechange = function (request) {
						if (request.target && request.target.readyState == 4) {
							WinJS.Application.local.remove('CachedCrashReport');
							return;
						}
					};
					xmlhttp.send(param({ data: JSON.stringify(data) }));
				}).done();
			}
		}).done();
	};

	/**
	 * Closure function for unhandled exceptions
	 *
	 */
	Bugsense.prototype.onerror = function bugsenseonerror(exception, url, line, column, custom_data) {
		// Ignore bugsense raised exception
		if (window.bugsense.isBugsenseException(exception))
			return false;
		return window.bugsense.notify(exception, url, line, column, custom_data);
	};

	Bugsense.prototype.onpromiseerror = function bugsenseonpromiseerror(event) {
		// Ignore bugsense raised exception
		if (window.bugsense.isBugsenseException(exception))
			return false;
		return window.bugsense.notify(event.detail.exception, event.detail.promise);
	};

	return Bugsense;

}));

(function(root, factory){
	'use strict';

	// CommonJS
	if (typeof exports === 'object' && module){
		module.exports = factory();
		// AMD
	} else if (typeof define === 'function' && define.amd){
		define(factory);
	}

	// Browser
	root.FilterJS = factory();

})( (typeof window === 'object' && window ) || this, function(){
	'use strict';

	var FilterJS = function(){
		this.hooks = {};
		this.version = '0.0.1';
	};

	FilterJS.prototype = {
		/**
		 * Returns the callbacks assigned to a specific name.
		 * */
		getHooks: function(name){
			if(!this.hooks.hasOwnProperty(name) || !(this.hooks[name] instanceof Array)){
				this.hooks[name] = [];
			}
			return this.hooks[name];
		},
		/**
		 * Adds a callback for a specific filter. It can accept an array of callbacks.
		 * */
		addFilter: function(name, cb){
			var hooks = this.getHooks(name);

			if(cb instanceof Array){
				for(var i = 0, l = cb.length; i < l; i++){
					hooks.push(cb[i]);
				}
			} else {
				hooks.push(cb);
			}
		},
		/**
		 * Removes the specified callback from the specified filter. Can remove an array of callbacks.
		 * */
		removeFilter: function(name, cb){
			var listeners = this.getHooks(name), index = -1;

			if(cb instanceof Array){
				for(var i = 0, l = cb.length; i < l; i++){
					index = listeners.indexOf(cb[i]);
					if(index !== -1){
						listeners.splice(index, 1);
					}
				}
			} else {
				index = listeners.indexOf(cb);
				if(index !== -1){
					listeners.splice(index, 1);
				}
			}
		},
		/**
		 * Removes all hooks attached to a filter.
		 * */
		removeAllFilters: function(name){
			var hooks = this.getHooks(name);
			for(var i = 0, l = hooks.length; i < l; i++){
				this.removeFilter(name, hooks[i]);
			}
		},
		/**
		 * Applies the hooks of a given filter.
		 * */
		applyFilters: function(name, data){
			var result = data;
			var hooks = this.getHooks(name);
			for(var i = 0, l = hooks.length; i < l; i++){
				var hook = hooks[i];
				if(typeof hook === 'function'){
					result = hook(result);
				}
			}
			return result;
		}
	};

	return FilterJS;
});
'use strict';

/* jshint unused: true */
/* exported Reader */
/* globals $ */

var Reader = (function (r) {
	// This is a private array of bookmarks for the current book. The data is organised based on chapters.
	// Ex: `_bookmarks[1]` contains an array of bookmarks from the first chapter.
	var _bookmarks = [];

	// The **Bookmarks** object exposes methods to allow the user to manage their bookmarks.
	//
	// * [`getBookmarks`](#getBookmarks)
	// * [`setBookmarks`](#setBookmarks)
	// * [`removeBookmark`](#removeBookmark)
	// * `goToBookmark`
	// * `reset`
	// * [`display`](#display)
	r.Bookmarks = {
		// <a name="getBookmarks"></a> Public getter function.
		getBookmarks: function(){
			return _bookmarks;
		},
		getVisibleBookmarks: function(){
			var bookmarks = [];
			$('.bookmark[data-cfi]', r.$iframe.contents()).each(function(index, el){
				if(r.returnPageElement(el) === r.Navigation.getPage()){
					bookmarks.push($(el).attr('data-cfi'));
				}
			});
			return bookmarks;
		},
		// <a name="setBookmarks"></a>This function will set the bookmarks based on the chapter they appear in.
		// `val` is an array of cfi-s representing the current book's bookmarks.
		setBookmarks: function(val, noMarker){
			if($.isArray(val)){
				$.each(_bookmarks, function(i, el){
					if($.isArray(el)){
						$.each(el, function(index, cfi){
							r.Bookmarks.removeBookmark(cfi);
						});
					}
				});
				_bookmarks = [];
				$.each(val, function(i, element){
					r.Bookmarks.setBookmark(element, noMarker);
				});
			}
		},

		// <a name="setBookmark"></a>This function saves a bookmark in the appropriate location, based on the chapter it appears in, and returns the cfi object associated with it.
		//
		// * `cfi` (optional) the cfi to save as a bookmark, otherwise the current page's cfi will be used.
		// * `noMarker` (optional) flag to indicate the bookmark does not require a marker inserted into the DOM.
		setBookmark: function(cfi, noMarker){
			var cfiObj = null;
			if(typeof(cfi) === 'undefined'){
				cfiObj = r.Navigation.getCurrentCFI();
				if($.type(cfiObj) === 'object'){
					cfi = cfiObj.CFI;
				} else {
					r.Notify.error($.extend({}, r.Event.ERR_CFI_GENERATION, {details: cfiObj, call: 'setBookmark'}));
					return false;
				}
			}

			var index = r.CFI.getChapterFromCFI(cfi);
			if(index !== -1){
				if(!$.isArray(_bookmarks[index])){
					_bookmarks[index] = [];
				}
				if($.inArray(cfi, _bookmarks[index]) === -1){
					_bookmarks[index].push(cfi);
					if(!noMarker && index === r.Navigation.getChapter()){
						r.CFI.setCFI(cfi);
						r.Bookmarks.display();
					}
					return cfiObj !== null ? JSON.stringify(cfiObj) : cfi;
				}
			}
			// bookmark exists
			r.Notify.error($.extend({}, r.Event.ERR_BOOKMARK_EXISTS, {details: cfi, call: 'setBookmark'}));
			return false;
		},
		// <a name="removeBookmark"></a>This function will remove a bookmark from the book and any associated DOM elements.
		// * `cfi` (required) the CFI of the bookmark to remove.
		removeBookmark: function(cfi){
			var chapter = r.CFI.getChapterFromCFI(cfi);
			if(chapter !== -1){
				var index = $.inArray(cfi, _bookmarks[chapter]);
				if($.isArray(_bookmarks[chapter]) && index !== -1){
					_bookmarks[chapter][index] = null;

					var $marker = $('*[data-cfi="' + cfi + '"]', r.$iframe.contents());
					if($marker.length){
						var $parent = $marker.parent();
						$marker.remove();

						// this restates the DOM to the previous structure
						// todo do not alter the DOM in the first place
						$parent[0].normalize();
					}

					r.Bookmarks.display();
					return true;
				}
			}
			// cannot remove bookmark
			r.Notify.error({}, $.extend(r.Event.ERR_BOOKMARK_REMOVE, {details: cfi, call: 'removeBookmark'}));
			return false;
		},
		goToBookmark: function(cfi){
			return r.CFI.goToCFI(cfi);
		},
		reset: function(){
			_bookmarks = [];
		},
		// <a name="display"></a>This function refreshes the bookmark UI. If a bookmark is visible on the current page, it will display the bookmark UI. Ignores mobile readers.
		display: function(){
			var isVisible = false;
			$('.bookmark', r.$iframe.contents()).each(function(index, el){
				isVisible = r.returnPageElement(el) === r.Navigation.getPage();
				if (isVisible) {
					return false;
				}
			});
			if (r.mobile) {
				return isVisible;
			}
			if(isVisible){
				$('#cpr-bookmark-ui', r.$iframe.contents()).show();
				return isVisible;
			} else {
				$('#cpr-bookmark-ui', r.$iframe.contents()).hide();
			}
			return false;
		}
	};

	// This function returns a stringified version of the table of contents. It is mainly used on mobile readers.
	r.getTOC = function(){
		return JSON.stringify(r.TOC);
	};

	r.getSPINE = function(){
		return JSON.stringify(r.SPINE);
	};


	// Initialize the table of contents.
	r.TOC = [];

	// Debug flag, used to log various events for debugging purposes
	var _debug = false;
	r.Debug = {
		enable: function enableDebug(){
			_debug = true;
		},
		disable: function disableDebug(){
			_debug = false;
		},
		log: function logDebug(s){
			if(_debug){
				console.warn(s);
			}
		}
	};

	return r;
}(Reader || {}));

'use strict';

/* jshint unused: true */
/* exported Reader */
/* globals $, EPUBcfi */

var Reader = (function (r) {
	// Private array for blacklisted classes. The CFI library will ignore any DOM elements that have these classes.
	// [Read more](https://github.com/readium/EPUBCFI/blob/864527fbb2dd1aaafa034278393d44bba27230df/spec/javascripts/cfi_instruction_spec.js#L137)
	var _classBlacklist = ['bookmark', 'cpr-marker'];

	// The **CFI** object exposes methods to handle CFIs. it is **not** intended to be exposed to the client directly.
	//
	// * [`setUp`](#setUp)
	// * [`getCFIObject`](#getCFIObject)
	// * [`setCFI`](#setCFI)
	// * [`addOneNodeToCFI`](#addOneNodeToCFI)
	// * [`addOneWordToCFI`](#addOneWordToCFI)
	// * [`goToCFI`](#goToCFI)
	// * reset

	// Helper methods:
	//
	// * [`updateContext`](#updateContext)
	// * [`addContext`](#addContext)
	// * [`removeContext`](#removeContext)
	// * [`addOneNodeToCFI`](#addOneNodeToCFI)
	// * [`getChapterFromCFI`](#getChapterFromCFI)
	//
	// Other private methods
	//
	// * [`getFirstNode`](#getFirstNode)
	r.CFI = {
		// The `opfCFI` is used to generate the first part of any valid CFI. This part points to the **file** containing the chapter.
		opfCFI: null,
		// Variable that contains a partial CFI representing the DOM tree between the reader container and the body. It is different between clients and has to be constructed dynamically.
		context: null,
		// <a name="setUp"></a>  Initialises the CFI variables, should be called whenever we load a new chapter
		// `chapter` the current chapter
		setUp: function (chapter) {
			if (r.opf === null) {
				return;
			}
			try {
				var chapterId = $(r.opf).find('spine').children()[chapter].getAttribute('idref');
				r.CFI.opfCFI = EPUBcfi.Generator.generatePackageDocumentCFIComponent(chapterId, r.opf);
			} catch (err) {
				// cannot generate CFI
				r.Notify.error($.extend({}, r.Event.ERR_CFI_GENERATION, {details: err, call: 'CFI.setUp'}));
			}
		},
		// <a name="updateContext"></a> This function will generate the CFI path between the body and the reader, specific to every client.
		updateContext: function(){
			if(!r.$reader || !r.CFI.opfCFI){
				return;
			}

			var elCFI = EPUBcfi.Generator.generateElementCFIComponent(r.$reader[0]);
			var completeCFI = EPUBcfi.Generator.generateCompleteCFI(r.CFI.opfCFI, elCFI);
			var part_1 = completeCFI.split('!/4')[1];
			r.CFI.context = part_1.split('[' + (r.$reader[0].id) + ']')[0] + '[' + (r.$reader[0].id) + ']';
		},
		// <a name="addContext"></a> This function will add the context into a CFI to generate a complete and valid CFI to be used with the current chapter.
		addContext: function(completeCFI){
			if($.type(completeCFI) !== 'string'){
				return;
			}
			// The reader context would not normally be updated anymore, but this is a workaround to the web-app, when they move the reader in the DOM and the context changes. Until that is fixed, we must update the context all the time.
			// if(r.CFI.context === null){
			r.CFI.updateContext();
			// }

			if(completeCFI.indexOf('!/4') !== -1){
				// Remove any IDs that contain "."
				completeCFI = completeCFI.replace(/\[([\w-_])*\.([\w-_])*\]/gi, '');
				// Take into account the style tags and Google font tag (current node -= 2/3)
				var contextSplit = completeCFI.split('!/4');
				completeCFI = contextSplit[0] + '!/4' + r.CFI.context + contextSplit[1];
			}

			return completeCFI;
		},
		// <a name="removeContext"></a> This function will remove the context from a CFI to generate a re-usable, generic, CFI.
		removeContext: function(completeCFI){
			if($.type(completeCFI) !== 'string'){
				return;
			}
			// The reader context would not normally be updated anymore, but this is a workaround to the web-app, when they move the reader in the DOM and the context changes. Until that is fixed, we must update the context all the time.
			// if(r.CFI.context === null){
			r.CFI.updateContext();
			// }

			if(completeCFI.indexOf(r.CFI.context) !== -1){
				completeCFI = completeCFI.replace(r.CFI.context, '');
				// Remove any IDs that contain "."
				completeCFI = completeCFI.replace(/\[([\w-_])*\.([\w-_])*\]/gi, '');
			}

			return completeCFI;
		},

		// <a name="getCFIObject"></a> Return the current position's CFI and a preview of the current text.
		getCFIObject: function() {
			// The reader context would not normally be updated anymore, but this is a workaround to the web-app, when they move the reader in the DOM and the context changes. Until that is fixed, we must update the context all the time.
			// if(r.CFI.context === null){
			r.CFI.updateContext();
			// }

			try {
				var startTextNode = getFirstNode();
				var elCFI = null;

				if (startTextNode.textNode.nodeType === 3) {
					elCFI = EPUBcfi.Generator.generateCharacterOffsetCFIComponent(startTextNode.textNode, startTextNode.offset, _classBlacklist);
				} else if (startTextNode.textNode.nodeType === 1) {
					elCFI = EPUBcfi.Generator.generateElementCFIComponent(startTextNode.textNode, _classBlacklist);
				}
				if (elCFI !== null) {

					var completeCFI = EPUBcfi.Generator.generateCompleteCFI(r.CFI.opfCFI, elCFI);
					var i;
					// getFirstNode does not have a blacklist and the injected markers break the CFI generation.
					// To ensure the correct CFI is generated, we must test it first. If the EPUBcfi library returns more than one text nodes, we must update the offset to include the previous text nodes.
					// the complete CFi must not contain any '.' (processed normally, but not here)
					var $node = $(EPUBcfi.Interpreter.getTargetElement(completeCFI.replace(/\[([\w-_])*\.([\w-_])*\]/gi, ''), r.$iframe.contents()[0], _classBlacklist));
					if($node.length > 1 && $node[0].nodeType === 3) {
						var offset = startTextNode.offset;
						for(i = 0; i < $node.length - 1; i++){
							if($($node[i]).is(startTextNode.textNode)){
								break;
							}
							offset += $node[i].length;
						}
						completeCFI = completeCFI.replace(/:\d+/, ':' + offset);
					}

					var result = {
						CFI: r.CFI.removeContext(completeCFI),
						preview: startTextNode.preview
					};

					var chapter =  r.CFI.getChapterFromCFI(result.CFI);
					var sections = [];

					var _parseItem = function(item){
						if(item.href.indexOf(href) !== -1){
							sections.push(item);
						}
						if(item.children){
							for(var i = 0, l = item.children.length; i < l; i++){
								_parseItem(item.children[i]);
							}
						}
					};

					if(chapter !== -1){
						var href = r.SPINE[chapter].href;
						for(i = 0; i < r.TOC.length; i++){
							_parseItem(r.TOC[i]);
						}
					}
					if(sections.length){
						if(sections.length > 1){
							var currentPage =  r.Navigation.getPage();
							// if more than one match, compare page numbers of different elements and identify where the current page is
							for(var j = 0, l = sections.length; j < l; j++){
								// get the anchor the url is pointing at
								var anchor = sections[j].href.split('#');
								anchor = anchor.length > 1 ? '#'+anchor[1] : null;
								if(!anchor){
									continue;
								} else {
									var $anchor = $(anchor, r.$iframe.contents());
									// we have to check if the element exists in the current chapter. Samples sometimes cut portions of the document, resulting in missing links
									if($anchor.length){
										var anchorPage = r.returnPageElement($anchor);
										if(anchorPage > currentPage){
											break;
										}
										result.chapter = sections[j].label;
									}
								}
							}
						} else {
							result.chapter = sections[0].label;
						}
					}
					return result;
				}
				return null;
			}
			catch (err) {
				// cannot generate CFI
				r.Notify.error($.extend({}, r.Event.ERR_CFI_GENERATION, {details: err, call: 'getCFIObject'}));
			}
		},
		getCFI: function() {
			return encodeURIComponent(JSON.stringify(r.CFI.getCFIObject()));
		},
		// <a name="setCFI"></a> This function will inject a blacklisted market into the DOM to allow the user to identify where a CFI points to.
		setCFI: function (cfi, markerClass) { // Add an element to a CFI point
			if($('.'+(markerClass ? markerClass : 'bookmark')+'[data-cfi="' + cfi + '"]', r.$iframe.contents()).length === 0){
				try {
					var marker = '<span class="'+ (markerClass ? markerClass : 'bookmark') +'" data-cfi="' + cfi + '"></span>';
					cfi = r.CFI.addContext(cfi);
					var $node = $(EPUBcfi.Interpreter.getTargetElement(cfi, r.$iframe.contents()[0], _classBlacklist));
					if ($node.length) {
						if ($node[0].nodeType === 1) { // append to element
							$node.before($(marker));
						}
						if ($node[0].nodeType === 3) { // inject into the text node
							r.CFI.addOneWordToCFI(cfi, $node, marker);
						}
					}
					return $node;
				}
				catch (err) {
					// cannot insert CFI
					r.Notify.error($.extend({}, r.Event.ERR_CFI_INSERTION, {details: err, call: 'setCFI'}));
				}
			}
		},
		// <a name="addOneNodeToCFI"></a> Helper function that moves the CFI to the next node. This is required to avoid a bug in some browsers that displays the current CFI on the previous page.
		addOneNodeToCFI : function (c, el, marker) {
			var $nextNode = getNextNode(el);

			// get the leaf of next node to inject in the appropriate location
			while ($nextNode && $nextNode.contents().length){
				$nextNode = $nextNode.contents().first();
			}

			var cfi = c;
			if ($nextNode) {
				if ($nextNode[0].nodeType === 3 && $nextNode[0].length > 1) {
					cfi = EPUBcfi.Generator.generateCharacterOffsetCFIComponent($nextNode[0], 0, _classBlacklist);
					cfi = EPUBcfi.Generator.generateCompleteCFI(r.CFI.opfCFI, cfi);
					r.CFI.addOneWordToCFI(cfi, $nextNode, marker);
				} else {
					$nextNode.before($(marker));
				}
				return true;
			}
			return false;
		},
		// <a name="addOneWordToCFI"></a> Add one position to the cfi if we are in a text node to avoid the CFI to be set in the previous page.
		addOneWordToCFI : function (cfi, el, marker) {
			var pos = parseInt(cfi.split(':')[1].split(')')[0], 10);
			var words = el.text().substring(pos).split(/\s+/).filter(function(word){
				return word.length;
			});
			// find next word position
			if (el.text().length > 1 && words.length && pos + words[0].length < el.text().length) {
				pos = pos + words[0].length;
				cfi = cfi.split(':')[0] + ':' + pos + ')';
				EPUBcfi.Interpreter.injectElement(cfi, r.$iframe.contents()[0], marker, _classBlacklist);
			} else {
				// We must check if there are more nodes in the chapter.
				// If not, we add the marker one character after the cfi position, if possible.
				if(!r.CFI.addOneNodeToCFI(cfi, el, marker)){
					pos = pos + 1 < el.text().length ? pos + 1 : pos;
					cfi = cfi.split(':')[0] + ':' + pos + ')';
					EPUBcfi.Interpreter.injectElement(cfi, r.$iframe.contents()[0], marker, _classBlacklist);
				}
			}
		},
		findCFIElement : function (value) {
			var $elem = $('*[data-cfi="' + value + '"]', r.$iframe.contents());
			return $elem.length ? r.returnPageElement($elem) : -1;
		},
		// <a name="goToCFI"></a>Find and load the page that contains the CFI's marker. If the marker does not exist, it will be injected in the chapter. If the CFI points to another chapter it will load that chapter first.
		goToCFI : function (cfi, fixed) {
			function _go(){
				if (r.CFI.findCFIElement(cfi) === -1) {
					r.CFI.setCFI(cfi, 'cpr-marker');
				}
				return r.Navigation.loadPage(cfi, fixed);
			}
			var chapter = r.CFI.getChapterFromCFI(cfi);
			if(chapter !== -1){
				if(r.Navigation.getChapter() === chapter){
					return _go();
				} else {
					return r.loadChapter(chapter).then(_go);
				}
			}
			r.Notify.error($.extend({}, r.Event.ERR_INVALID_ARGUMENT, {details: 'Invalid CFI', value: cfi, call: 'goToCFI'}));
			return $.Deferred().reject().promise();
		},
		// <a name="getChapterFromCFI"></a> This function will calculate what chapter the CFI is pointing at and return the its index (or -1 on failure).
		getChapterFromCFI: function(cfi){
			if($.type(cfi) === 'string'){
				var chapter = cfi.split('/');
				if(chapter.length >= 3 && $.isNumeric(chapter[2].slice(0, -1))){
					return parseInt(parseInt(chapter[2].slice(0, -1), 10) / 2 - 1, 10);
				}
			}
			return -1;
		},
		reset : function(){
			r.CFI.opfCFI = null;
			r.CFI.context = null;
		}
	};

	// <a name="getFirstNode"></a> Helper function that returns the first node in the current page displayed by the reader.
	var getFirstNode = function () {

		var range;
		var textNode;
		var offset;
		var container = r.$reader[0];
		var rect = container.getBoundingClientRect();
		var left = r.getReaderLeftPosition();
		var document = r.$iframe.contents()[0];

		/* standard */
		if (document.caretPositionFromPoint) {
			range = document.caretPositionFromPoint(rect.left - left, rect.top);
			textNode = range.offsetNode;
			offset = range.offset;
			/* WebKit */
		} else if (document.caretRangeFromPoint) {
			range = document.caretRangeFromPoint(rect.left - left, rect.top);
			textNode = range.startContainer;
			offset = range.startOffset;
		}

		/* Make sure textNode is part of the reader... */
		if (!r.$reader.has(textNode).length) {
			/* Reset offset since textNode changed. */
			offset = 0;
			/* TextNode is the first node that contains text, otherwise get the first child node. */
			textNode = container.childNodes.length > 0 && $(container.childNodes[0]).text().trim().length ? container.childNodes[0] : r.$reader.children().first()[0];
		}

		var findLeafNode = function (el) {
			var $el = $(el);
			/* Return a non-empty textNode or null */
			if (el === null || !el.childNodes || el.childNodes.length === 0) {
				return el;
			}
			/* Return the element if it only has one child and it is in the blacklist */
			if (el.childNodes.length === 1 && _hasClass($el.contents(), _classBlacklist)) { // TODO: Explore more options
				return el;
			}
			for(var i = 0, l = $el.contents().length; i < l; i++){
				var $child = $($el.contents()[i]);
				if(!_hasClass($child, _classBlacklist)){
					/* reset offset since textNode changed */
					offset = 0;
					return findLeafNode($child[0]);
				}
			}
			return el;
		};

		/* generate a preview from the current position */
		var preview = '',
			words = 0;

		// Calculates the length of a string and returns true if the length has the minimum number of words.
		// Returns true if text is a string and its length is > than the desired number of words, false otherwise.
		var hasDesiredLength = function (text) {
			if ($.type(text) !== 'string') {
				return false;
			}

			// Check number of words so far.
			var whitespaces = text.match(/\S+/g);
			words = whitespaces ? text.match(/\S+/g).length : 0;
			return words > 100;
		};

		var _hasClass = function (el, classNames) {
			var classes = '.' + classNames.join(', .');
			return el.filter(classes).length > 0;
		};

		// Loops through all adjacent nodes to generate the preview, starting with the first text node.
		var generatePreview = function () {
			var $currentNode = $(textNode);
			var text = offset ? '&#8230;' + $currentNode.text().substr(offset) : $currentNode.text();  // prepend ellipses to previews which don't begin at the start of a sentence

			generatePreview :
			while (!hasDesiredLength(text)) {
				var $next = getNextNode($currentNode);

				if ($next && $next.length) {
					$currentNode = $next;
					text += $currentNode.text().length && $currentNode[0].tagName !== 'SCRIPT' ? $currentNode.text().trim() + ' ' : '';
				} else {
					// No more content go get text from, break operation.
					break generatePreview;
				}
			}

			// Trim preview to 100 words.
			var trimmed = text.trim().match(/((\S+\s+){100})/);
			return trimmed && trimmed.length ? trimmed[0] : text;
		};

		// Get the top element that is the child of the reader container.
		var $currentNode = $(textNode);
		while ($currentNode.parent().length && !$currentNode.parent().is(r.$reader)) {
			$currentNode = $currentNode.parent();
		}

		// Check that the first tag has text, if not, add any image/table we can find.
		if (!$currentNode.text().trim().length) {
			var $img = $currentNode.find('img');
			var $table = $currentNode.find('table');
			var $svg = $currentNode.find('svg');

			if ($img.length) {
				preview = 'Image: ' + ($img.attr('alt') ? $img.attr('alt') : 'No description');
			} else if ($table.length) {
				preview = 'Table';
			} else if ($svg.length) {
				preview = 'Image: No description';
			}
		} else {
			preview = generatePreview();
		}

		return {
			textNode: findLeafNode(textNode),
			offset: offset,
			preview: preview
		};
	};

	var getNextNode = function ($el) {
		if ($el.length) {
			$el = $el.last();
			var nodes = $el.parent().contents().filter(function(i, e){
				return !$(e).hasClass(_classBlacklist.join(',.'));
			});
			var index = $.inArray($el[0], nodes);
			if (nodes[index + 1]) {
				var $next = $(nodes[index + 1]);
				// ignore empty textnodes
				if($next[0].nodeType === 3 && !$next.text().trim().length){
					return getNextNode($next);
				}
				return $next;
			} else if (!$el.parent().is(r.$reader)) {
				return getNextNode($el.parent());
			}
		}
		return null;
	};

	return r;
}(Reader || {}));
/**
 * ReaderJS v1.0.0
 * (c) 2013 BlinkboxBooks
 * config.js: contains global variables
 */

/* jshint unused: true */
/* exported Reader */
/* globals $ */

var Reader = (function (r) {
	'use strict';

	// Constants
	r.DOCROOT = '';
	r.INF = 'META-INF/book-info.json';
	r.CONTENT_PATH_PREFIX = '';
	r.OPF = '';

	// Book data
	r.opf = null;

	// Initial settings.
	r.Layout = {
		Container: {
			width: 0,
			height: 0
		},
		Reader: {
			width: 0,
			height: 0,
			columns: 1,
			padding: 0
		}
	};
	r.$iframe = null;
	r.$wrap = null;
	r.$head = null;
	r.$container = null;
	r.$reader = null;
	r.$header = null;
	r.$footer = null;
	r.$stylesheet = null;

	// Indicates if the Reader has been called from a mobile app.
	r.mobile = false;
	// DOM object
	r.listener = null;
	// User-set preferences that are related to the display options.
	var i, rule;
	r.preferences = {
		lineHeight : {
			rules: [],
			min: 1.1,
			max: 20,
			unit: 0.1,
			value: 1.6,
			applyRules: function(){
				for(i = 0; i< r.preferences.lineHeight.rules.length; i++){
					rule = r.preferences.lineHeight.rules[i];
					rule.rule[rule.property] = r.preferences.lineHeight.value + 'em';
				}
			}
		},
		fontSize : {
			rules: [],
			min: 0.5,
			max: 15,
			unit: 0.1,
			value: 1.125,
			applyRules: function(){
				for(i = 0; i< r.preferences.fontSize.rules.length; i++){
					rule = r.preferences.fontSize.rules[i];
					rule.rule[rule.property] = (r.preferences.fontSize.value * 18) + 'px';
				}
			}
		},
		fontFamily : {
			rules: [],
			value: '',
			applyRules: function(){
				for(i = 0; i< r.preferences.fontFamily.rules.length; i++){
					rule = r.preferences.fontFamily.rules[i];
					rule.rule[rule.property] = r.preferences.fontFamily.value;
				}
			}
		},
		margin : { // top, right, bottom, left
			min : [9.8, 4, 6.5, 4],
			max: [9.8, 17.75, 6.5, 17.75],
			medium: [9.8, 11, 6.5, 11],
			value: [9.8, 11, 6.5, 11],
			// Helper function that sets a valid margin from an argument.
			clear: function(args){
				// Replace keywords with their respective values...
				if(args === 'min'){
					args = r.preferences.margin.min;
					return args;
				}
				else if(args === 'max'){
					args = r.preferences.margin.max;
					return args;
				}
				if(args === 'medium'){
					args = r.preferences.margin.medium;
					return args;
				}
				// Make sure the args are an array of length 4...
				if(!Array.isArray(args) || args.length !== 4){
					// Only send error notification if the client actually attemted to set the value
					if(args){
						r.Notify.error($.extend({}, r.Event.ERR_INVALID_ARGUMENT, {value: args, details: 'The reader margin has to be defined as either min, max or medium. Alternatively, you can define your own values by sending an array in the following format [top, right, bottom, left].', call: 'margin'}));
					}
					args = r.preferences.margin.value;
				}

				// Make sure bounds are respected...
				for(var  i = 0; i < args.length; i++){
					args[i] = args[i] < r.preferences.margin.min[i] ? r.preferences.margin.min[i] : args[i];
					args[i] = args[i] > r.preferences.margin.max[i] ? r.preferences.margin.max[i] : args[i];
				}
				return args;
			}
		},
		theme : {
			rules: {
				background: [],
				title: [],
				color: []
			},
			transparent : {
				background : 'transparent',
				title : '#666',
				color : '#000'
			},
			light : {
				background : '#f4f4f4',
				title : '#666',
				color : '#000'
			},
			dark : {
				background : '#000000',
				title : '#666',
				color : '#dddddd'
			},
			sepia : {
				background : '#ede7d5',
				title : '#666',
				color : '#181818'
			},
			value : {
				background : '#f4f4f4',
				title : '#666',
				color : '#000'
			},
			clear : function(args){
				if(args === 'light' || args === 'dark' || args === 'sepia' || args === 'transparent'){
					return r.preferences.theme[args];
				}
				if(typeof(args) === 'object' && args.hasOwnProperty('color') && args.hasOwnProperty('background') && args.hasOwnProperty('title')){
					return args;
				}
				if(args){
					r.Notify.error($.extend({}, r.Event.ERR_INVALID_ARGUMENT, {value: args, details: 'The reader theme has to be either transparent, light, dark or sepia. Alternatively you can set your own custom theme by sending an object with background and color properties defined.', call: 'theme'}));
				}
				return r.preferences.theme.value;
			},
			applyRules: function(){
				for(i = 0; i< r.preferences.theme.rules.background.length; i++){
					rule = r.preferences.theme.rules.background[i];
					rule.rule[rule.property] = r.preferences.theme.value.background;
				}
				for(i = 0; i< r.preferences.theme.rules.title.length; i++){
					rule = r.preferences.theme.rules.title[i];
					rule.rule[rule.property] = r.preferences.theme.value.title;
				}
				for(i = 0; i< r.preferences.theme.rules.color.length; i++){
					rule = r.preferences.theme.rules.color[i];
					rule.rule[rule.property] = r.preferences.theme.value.color;
				}
			}
		},
		textAlign:{
			rules: [],
			values: ['left', 'justify'],
			value: 'left',
			clear: function(args){
				if(args && (typeof(args) !== 'string' || $.inArray(args, r.preferences.textAlign.values) === -1)){
					r.Notify.error($.extend({}, r.Event.ERR_INVALID_ARGUMENT, {value: args, details: 'The text align has to be either left or justify.', call: 'textAlign'}));
					return r.preferences.textAlign.value;
				}
				return args;
			},
			applyRules: function(){
				for(i = 0; i< r.preferences.textAlign.rules.length; i++){
					rule = r.preferences.textAlign.rules[i];
					rule.rule[rule.property] = r.preferences.textAlign.value;
				}
			}
		},
		applyAll: function(){
			r.preferences.lineHeight.applyRules();
			r.preferences.fontSize.applyRules();
			r.preferences.fontFamily.applyRules();
			r.preferences.theme.applyRules();
			r.preferences.lineHeight.applyRules();
			r.preferences.textAlign.applyRules();
		}
	};
	return r;

}(Reader || {}));
/**
 * ReaderJS v1.0.0
 * (c) 2013 BlinkboxBooks
 * display.js: methods for create the container and display the content
 */

/* jshint unused: true */
/* exported Reader */
/* globals $, Bugsense */

var Reader = (function (r) {
	'use strict';

	var _initCFI = null, _initURL = null;

	// **Init function**
	//
	// Assign parameters to the global variables.
	//
	// * `param` Contains the parameters: container (id), chapters, padding, url, mobile, dimensions (width and height) etc.
	r.init = function(param) {
		r.reset(); // Reset the reader values.
		if (!param) { param = {}; }
		_initCFI = null;
		_initURL = null;

		// Take the params {container, chapters, width, height, padding, _mobile} or create them.
		// todo validate container
		r.$parent = $(param.container).empty();
		r.$iframe = $('<iframe scrolling="no" seamless="seamless" src="javascript:undefined;"></iframe>').appendTo(r.$parent);
		r.$head = r.$iframe.contents().find('head');
		r.$wrap = r.$iframe.contents().find('body');
		r.$container = $('<div></div>').appendTo(r.$wrap);
		r.$reader = $('<div id="cpr-reader"></div>').appendTo(r.$container);
		r.$header = $('<div id="cpr-header"></div>').insertBefore(r.$container);
		r.$footer = $('<div id="cpr-footer"></div>').insertAfter(r.$container);

		// Add bookmark mark
		$('<span id="cpr-bookmark-ui"></span>').insertAfter(r.$container);

		// add styles and fonts
		_addStyles();

		r.listener = (param.hasOwnProperty('listener')) ? param.listener : null;

		r.DOCROOT = (param.hasOwnProperty('url')) ? param.url : '';
		r.ISBN = (param.hasOwnProperty('isbn')) ? param.isbn : '';

		// Set the mobile flag.
		r.mobile = !!((param.hasOwnProperty('mobile')));

		// Save the initial bookmarks.
		r.Bookmarks.setBookmarks((param.hasOwnProperty('bookmarks')) ? param.bookmarks : [], true);

		// Set the initial position.
		_initCFI = param.hasOwnProperty('initCFI') ? param.initCFI : _initCFI;
		_initURL = param.hasOwnProperty('initURL') ? param.initURL : _initURL;

		// Resize the container with the width and height (if they exist).
		_createContainer(param.width, param.height, param.columns, param.padding);

		// Apply all user preferences
		r.setPreferences(param.preferences);

		r.resizeContainer(param);

		// Enable bugsense reporting
		_setBugsense();

		// Start the party.
		return loadInfo();
	};

	var _addStyles= function(){
		var styles = 'html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block;vertical-align:baseline}audio:not([controls]){display:none;height:0}[hidden],template{display:none}a{background:0 0}a:active,a:hover{outline:0}abbr[title]{border-bottom:1px dotted}b,strong{font-weight:700}dfn{font-style:italic}h1{font-size:2em;margin:.67em 0}mark{background:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sup{top:-.5em}sub{bottom:-.25em}img{border:0}svg:not(:root){overflow:hidden}figure{margin:1em 40px}hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}pre{overflow:auto}code,kbd,pre,samp{font-family:monospace,monospace;font-size:1em}button,input,optgroup,select,textarea{color:inherit;font:inherit;margin:0}button{overflow:visible}button,select{text-transform:none}button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}button[disabled],html input[disabled]{cursor:default}button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}input{line-height:normal}input[type=checkbox],input[type=radio]{box-sizing:border-box;padding:0}input[type=number]::-webkit-inner-spin-button,input[type=number]::-webkit-outer-spin-button{height:auto}input[type=search]{-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}input[type=search]::-webkit-search-cancel-button,input[type=search]::-webkit-search-decoration{-webkit-appearance:none}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{border:0;padding:0}textarea{overflow:auto}optgroup{font-weight:700}table{border-collapse:collapse;border-spacing:0}td,th{padding:0}#cpr-bookmark-ui{display:none;position:absolute;right:0;top:0;background:#111;width:30px;height:30px;box-shadow:0 0 3px #666}#cpr-bookmark-ui::before{position:absolute;content:"";right:0;top:0;width:0;height:0;border:15px solid #000;border-right-color:transparent;border-top-color:transparent}#cpr-footer{color:#000;line-height:30px;text-align:center;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}#cpr-header{color:#fff;line-height:30px;text-align:center;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;width:100%}body{background:#fff;position:relative;overflow:hidden;margin:0;padding:0}body #cpr-reader{-webkit-backface-visibility:hidden;-webkit-perspective:1000;backface-visibility:hidden;perspective:1000}body #cpr-reader *,body #cpr-reader a,body #cpr-reader div,body #cpr-reader em,body #cpr-reader h1,body #cpr-reader h2,body #cpr-reader h3,body #cpr-reader h4,body #cpr-reader h5,body #cpr-reader h6,body #cpr-reader p,body #cpr-reader span,body #cpr-reader strong{padding:0;margin:0;font-weight:400;font-style:normal;text-decoration:none;text-align:left;color:#000;line-height:1.2;font-size:18px;font-family:Arial;word-wrap:break-word}body #cpr-reader h1,body #cpr-reader h2,body #cpr-reader h3,body #cpr-reader h4,body #cpr-reader h5,body #cpr-reader h6{font-weight:700;font-size:24px}body #cpr-reader p{margin-bottom:1em}body #cpr-reader :last-child{margin-bottom:0}body #cpr-reader :link{color:#09f;text-decoration:none;border-bottom:1px solid #09f}body #cpr-reader :link[data-link-type=external]:after{content:" ";font-size:.83em;vertical-align:super}body #cpr-reader :link *{color:#09f}body #cpr-reader img,body #cpr-reader svg,body #cpr-reader svg *{max-width:100%;max-height:100%}body #cpr-reader img.cpr-center,body #cpr-reader svg .cpr-center,body #cpr-reader svg.cpr-center{display:block;margin-right:auto;margin-left:auto}';

		r.$stylesheet = $('<style>' + styles + '</style>').appendTo(r.$head);

		// Save a reference for each style
		var rules = r.$stylesheet[0].sheet.cssRules;
		var i, l= rules.length, wrap_id = 'body', id = ' #' + r.$reader.attr('id');
    var _checkSelectors = function(v) { if (rule.selectorText) { return rule.selectorText.indexOf(v) >= 0; }};
		for(i=0; i< l; i++){
			var rule = rules[i];
      var selectors = [id +' *', id+' span', id+' p', id+' em', id+' div', id+' strong', id+' a', id+' h1', id+' h2', id+' h3', id+' h4', id+' h5', id+' h6'];
      if(selectors.every(_checkSelectors)){
				r.preferences.lineHeight.rules.push({rule: rule.style, property: 'lineHeight'});
				r.preferences.fontSize.rules.push({rule: rule.style, property: 'fontSize'});
				r.preferences.fontFamily.rules.push({rule: rule.style, property: 'fontFamily'});
				r.preferences.textAlign.rules.push({rule: rule.style, property: 'textAlign'});
				r.preferences.theme.rules.color.push({rule: rule.style, property: 'color'});
			} else if(rule.selectorText === wrap_id){
				r.preferences.theme.rules.background.push({rule: rule.style, property: 'background'});
			} else if(rule.selectorText === '#cpr-header' || rule.selectorText === '#cpr-footer'){
				r.preferences.theme.rules.title.push({rule: rule.style, property: 'color'});
			} else if(rule.selectorText === '#cpr-bookmark-ui'){
				r.preferences.theme.rules.background.push({rule: rule.style, property: 'background'});
			}
		}

		// Note, this is injected regardless if it exists or not
		if(!r.mobile){
			r.$head.append('<link href=\'//fonts.googleapis.com/css?family=Droid+Serif:400,700,700italic,400italic\' rel=\'stylesheet\' type=\'text/css\'>');
		}
	};

	var _setBugsense = function(){
		if (typeof Bugsense === 'function') {
			r.Bugsense = new Bugsense({
				apiKey: 'f38df951',
				appName: 'CPR',
				appversion: '0.1.34-105'
			});
			// Setup error handler
			window.onerror = function (message, url, line) {
				r.Notify.error(message, url, line);
				return false;
			};
		}
	};

	// Check and load an URL if it is in the spine or the TOC.
	var _checkURL = function (url) {
		var findURL = false;
		// The URL.
		var u = url[0];
		// The anchor.
		var a = url[1];
		// Link is in the actual chapter.
		var chapter = r.Navigation.getChapter();
		if ((r.SPINE[chapter].href.indexOf(u) !== -1 || u === '') && a !=='') {
			r.Navigation.loadPage(a);
			return true;
		}
		// Check the table of contents...
		for (var i=0; i<r.TOC.length; i++) {
			if (r.TOC[i].href.indexOf(u) !== -1 && r.TOC[i].active === true) { findURL = true; }
		}

		var _load = function(j,a){
			r.Notify.event(r.Event.LOADING_STARTED);
			r.loadAnchor.apply(r, [j,a]).always(function clickLoadComplete(){
				r.Notify.event(r.Event.LOADING_COMPLETE);
			}).then(
				function clickLoadSuccess(){
					r.Notify.event($.extend({}, Reader.Event.getStatus(), {call: 'clickLoad'}));
				},
				function clickLoadError(err){
					r.Notify.error(err);
				}
			);
		};

		// Check the spine...
		for (var j=0; j<r.SPINE.length;j++) {
			// URL is in the Spine and it has a chapter number...
			if (r.SPINE[j].href.indexOf(u) !== -1) {
				r.Navigation.setChapter(j);
				r.Navigation.setPage(0);

				// since this is a user generated even, we must handle callbacks here
				_load(j,a);
				return true;
			}
		}
		return findURL;
	};

	var _touchTimer, _touchData = {
		call: 'userClick',
		clientX: null,
		clientY: null
	};

	// For mobile devices, notify the client of any touch events that happen on the reader (that are not links)
	var _touchStartHandler = function(e){
		if($(e.target).is(':not(a)')){
			_touchTimer = (new Date()).getTime();
			_touchData.clientX = e.touches ? e.touches[0].clientX : null;
			_touchData.clientY = e.touches ? e.touches[0].clientY : null;
		}
	};

	var _touchEndHandler = function(e){
		// if the difference between touchstart and touchend is smalller than 300ms, send the callback, otherwise it's a long touch event
		if((new Date()).getTime() - _touchTimer < 300 && $(e.target).is(':not(a)')){
			r.Notify.event($.extend({}, Reader.Event.UNHANDLED_TOUCH_EVENT, _touchData));
		}
	};

	// Capture all the links in the reader
	var _clickHandler = function (e) {
		e.preventDefault();
		if (this.getAttribute('data-link-type') === 'external') {
			// External link, notify client about it
			r.Notify.event($.extend({}, Reader.Event.NOTICE_EXT_LINK, {call: 'userClick', href:this.getAttribute('href')}));
		} else if (this.getAttribute('data-link-type') === 'internal') {
			// Internal link
			// Reduce the URL to the name file (remove anchors ids)
			var url = this.getAttribute('href').split('#');
			// Check if the link exists in the spine and ask the user
			if (!_checkURL(url)) {
				r.Notify.event($.extend({}, Reader.Event.CONTENT_NOT_AVAILABLE, {call: 'userClick'}));
			}
		}
		// Stop event propagation
		if (e.stopPropagation) { e.stopPropagation(); }
	};

	// Display HTML content
	//
	// * `param` Contains the parameters: content, page and mimetype
	// * `callback` Function to be called after the function's logic
	var displayContent = function(param) {
		if (!param) { param = []; }
		// Take the params values
		var content = (param.hasOwnProperty('content')) ? param.content : '';
		var mimetype = (param.hasOwnProperty('mimetype')) ? param.mimetype : 'application/xhtml+xml';

		r.$header.text(r.bookTitle); // TODO Do not polute the reader object.

		// Parse the content according its mime-type and apply all filters attached to display content
		content = r.Filters.applyFilters(r.Filters.HOOKS.BEFORE_CHAPTER_DISPLAY, r.parse(content, mimetype));

		r.$reader.html(content);

		// Add all bookmarks for this chapter.
		var bookmarks = r.Bookmarks.getBookmarks()[r.Navigation.getChapter()];
		if(typeof(bookmarks) !== 'undefined'){
			$.each(bookmarks, function(index, bookmark){
				r.Navigation.setCFI(bookmark);
			});
		}
		return $.Deferred().resolve().promise();
	};

	// Define the container dimensions and create the multi column or adjust the height for the vertical scroll.
	//
	// * `width` In pixels
	// * `height` In pixels
	var _createContainer = function() {
		var doc = r.$iframe.contents()[0];
		r.$iframe.css({
			display: 'inline-block',
			border: 'none'
		});

		r.$reader.addClass(areColumnsSupported() ? 'columns' : 'scroll');

		// Container parent styles.
		r.$container
			.css({
				overflow: 'hidden'
			});

		// Capture the anchor links into the content
		r.$container.on('click', 'a', _clickHandler);

		// Set touch handler for mobile clients, to send back the coordinates of the click
		if(r.mobile){
			doc.removeEventListener('touchstart', _touchStartHandler);
			doc.addEventListener('touchstart', _touchStartHandler);
			doc.removeEventListener('touchend', _touchEndHandler);
			doc.addEventListener('touchend', _touchEndHandler);
		}
	};

	// Load the JSON file with all the information related to this book
	//
	// * `resource`
	var loadInfo = function() {
		var defer = $.Deferred();
		loadFile(r.INF, 'json').then(function bookInfoLoaded(data){
			r.SPINE = data.spine;
			r.TOC = data.toc;
			r.sample = data.sample;
			r.bookTitle = data.title;

			// Check for startCFI, save it if and only if initCFI is null
			_initCFI = data.startCfi && !_initCFI ? data.startCfi : _initCFI;

			// Validate initCFI (chapter exists)
			var chapter = r.CFI.getChapterFromCFI(_initCFI);
			if(chapter === -1 || chapter >= r.SPINE.length){
				chapter = 0;
				_initCFI = null;
			}

			// If the OPF is in a folder...
			if (data.opfPath.indexOf('/') !== -1) {
				var pathComponents = data.opfPath.split('/');
				r.CONTENT_PATH_PREFIX = '';
				for (var i = 0; i < (pathComponents.length-1); i++){
					if (i !== 0) {
						r.CONTENT_PATH_PREFIX += '/';
					}
					r.CONTENT_PATH_PREFIX  += pathComponents[i];
				}
			}
			// If the PATH is empty set its value with the path of the first element in the spine.
			if (r.CONTENT_PATH_PREFIX === '') {
				// Check the path has more then one component.
				if (r.SPINE[0].href.indexOf('/') !== -1) {
					r.CONTENT_PATH_PREFIX = r.SPINE[0].href.split('/')[0];
				}
			}
			// Set OPF
			r.OPF = data.opfPath;
			if (r.OPF !== '') {
				loadFile(r.OPF).then(function opfFileLoaded(opf){
					r.opf = opf;

					var promise; // promise object to return
					if(_initCFI === null){
						// if initURL is null, load the first chapter, otherwise load the specified chapter
						promise = !!_initURL ? r.Navigation.loadChapter(_initURL) : r.loadChapter(0);
					} else {
						// load the chapter specified by the CFI, otherwise load chapter 0
						promise = r.loadChapter(chapter);
					}
					promise.then(r.Navigation.loadPage).then(defer.resolve, defer.reject);
				}, defer.reject);
			}
			r.Navigation.setNumberOfChapters(data.spine.length); // Set number of chapters
		}, defer.reject);
		// notify client that info promise has been processed
		defer.notify();
		return defer.promise();
	};

	// Get a file from the server and display its content
	//
	// * `resource`
	// * `callback`
	var loadFile = function(resource, type) {
		var defer = $.Deferred();
		$.ajax({
			url: r.DOCROOT+'/'+resource,
			dataType: (type) ? type : 'text'
		}).then(defer.resolve, function(err){
				defer.reject($.extend({}, r.Event.ERR_MISSING_FILE, {details: err}));
			});
		return defer.promise();
	};

	// Load a chapter and go to the page pointed by the anchor value.
	r.loadAnchor = function(c,a){
		return r.loadChapter(c).then(function onLoadChapterSuccess(){
			return r.Navigation.loadPage(a);
		});
	};

	// Load a chapter with the index from the spine of this chapter
	r.loadChapter = function(chapterNumber) {
		var defer = $.Deferred();

		r.CFI.setUp(chapterNumber);
		r.Navigation.setChapter(chapterNumber);
		r.$reader.css('opacity', 0);

		// success handler for load chapter
		var loadChapterSuccess = function(data){
			displayContent({content: data}).then(function(){

				r.Navigation.setNumberOfPages();
				r.$reader.css('opacity', 1);

				// Go to init cfi, if it was set.
				if(_initCFI){
					r.CFI.goToCFI(_initCFI);
					_initCFI = null;
				}

				defer.resolve();
			}, defer.reject); // Execute the callback inside displayContent when its timer interval finish
		};

		// Check if the PATH is in the href value from the spine...
		if ((r.SPINE[chapterNumber].href.indexOf(r.CONTENT_PATH_PREFIX) !== -1)) {
			loadFile(r.SPINE[chapterNumber].href).then(loadChapterSuccess, defer.reject);
		} else {
			// If it is not, add it and load the chapter
			loadFile(r.CONTENT_PATH_PREFIX+'/'+r.SPINE[chapterNumber].href).then(loadChapterSuccess, defer.reject);
		}

		return defer.promise();
	};

	// Check if the browser supports css-columns.
	var areColumnsSupported = function () {
		var elemStyle = document.createElement('ch').style,
			domPrefixes = 'Webkit Moz O ms Khtml'.split(' '),
			prop = 'columnCount',
			uc_prop = prop.charAt(0).toUpperCase() + prop.substr(1),
			props   = (prop + ' ' + domPrefixes.join(uc_prop + ' ') + uc_prop).split(' ');

		for ( var i in props ) {
			if ( elemStyle[ props[i] ] !== undefined ) {
				return true;
			}
		}
		return false;
	};

	return r;

}(Reader || {}));

'use strict';

/* jshint unused: true */
/* exported Reader */
/* globals $ */

var Reader = (function (r) {

	// Register a listener to the reader. Any future events will notify it.
	r.registerListener = function(f){
		if (f && typeof(f) === 'function') {
			r.listener = f;
			return true;
		}
		return false;
	};

	// Check if this is the first or last page of the book, and fire the appropriate event.
	var _check_page_pos = function(status){
		if(status.page === 0 && status.chapter === 0){
			Reader.Notify.event(Reader.Event.FIRST_PAGE);
		}
		if(status.page === status.pages && status.chapter === status.chapters - 1){
			Reader.Notify.event(Reader.Event.LAST_PAGE);
		}
		return status;
	};


	// Events supported by the reader.
	//
	// * `LAST_PAGE` - raised when the reader has opened the last page
	// * `LAYOUT_UPDATE` - raised when the number of pages and current page have been updated and possibly changed
	// * `PROGRESS_UPDATED` - event raised when the progress of the book is updated.
	// * `FIRST_PAGE` - event raised when the book displayed the first page of the book.
	// * `END_OF_BOOK`
	r.Event = {
		LAST_PAGE : {
			code: 0,
			message: 'Reader has displayed the last page.'
		},
		END_OF_BOOK : {
			code: 2,
			message: 'The end of the book has been reached.'
		},
		FIRST_PAGE: {
			code: 4,
			message: 'Reader has displayed the first page.'
		},
		LOADING_STARTED: {
			code: 5,
			message: 'Reader is loading.'
		},
		LOADING_COMPLETE: {
			code: 6,
			message: 'Reader has finished loading.'
		},
		STATUS: {
			'code': 7,
			'message': 'Reader has updated its status.',
			'version': '0.1.34-105'
		},
		START_OF_BOOK : {
			code: 8,
			message: 'The start of the book has been reached.'
		},
		ERR_MISSING_FILE:{
			code: 9,
			message: 'A file required by the reader is missing from the ePub.'
		},
		ERR_PARSING_FAILED:{
			code: 10,
			message: 'Parsing of the current chapter failed.'
		},
		ERR_CFI_GENERATION:{
			code: 11,
			message: 'Could not generate a CFI for this location.'
		},
		ERR_CFI_INSERTION:{
			code: 12,
			message: 'Could not insert content at the location specified by the CFI.'
		},
		ERR_INVALID_ARGUMENT:{
			code: 13,
			message: 'An invalid argument was sent to the reader.'
		},
		ERR_BOOKMARK_ADD:{
			code: 14,
			message: 'Could not add the bookmark.'
		},
		ERR_BOOKMARK_EXISTS:{
			code: 15,
			message: 'Could not add the bookmark because one already exists in this location.'
		},
		ERR_BOOKMARK_REMOVE:{
			code: 16,
			message: 'Could not remove bookmark.'
		},
		NOTICE_EXT_LINK:{
			code: 17,
			message: 'External link will navigate away from the reader'
		},
		CONTENT_NOT_AVAILABLE: {
			code: 18,
			message: 'This is a sample, content not available'
		},
		UNHANDLED_TOUCH_EVENT: {
			code: 19,
			message: 'Unhandled touch event at given coordinates.'
		},
		getStatus: function(){
			return _check_page_pos($.extend({}, r.Event.STATUS, {
				'bookmarksInPage': Reader.Bookmarks.getVisibleBookmarks(), // true if there is a bookmark on the current page
				'bookmarks': Reader.Bookmarks.getBookmarks(), // array of bookmarks from the book
				'cfi': Reader.Navigation.getCurrentCFI(), // the current CFI
				'progress': Reader.Navigation.getProgress(), // the progress of the book
				'chapter': Reader.Navigation.getChapter(), // the current chapter
				'chapters': Reader.Navigation.getNumberOfChapters(), // total number of chapters
				'page': Reader.Navigation.getPage(), // the current page
				'pages': Reader.Navigation.getNumberOfPages(), // the total number of pages in the current chapter
				'preferences': {
					lineHeight: r.preferences.lineHeight.value,
					fontSize: r.preferences.fontSize.value,
					textAlign: r.preferences.textAlign.value,
					fontFamily: r.preferences.fontFamily.value,
					margin: r.preferences.margin.value,
					theme: r.preferences.theme.value
				},
				'layout': {
					width: r.Layout.Container.width,
					height: r.Layout.Container.height,
					columns: r.Layout.Reader.columns,
					padding: r.Layout.Reader.padding
				}
			}));
		}
	};

	// Notify clients of reader events
	var _notify = function(data){
		r.Debug.log(data);

		// Notify reader listener, if it exists
		if (r.listener && typeof(r.listener) === 'function') { r.listener(data); }

		// Perform callback to mobile clients
		if(r.mobile){
			$.ajax({
				url: 'BBBCALLBACK',
				type: 'POST',
				data: JSON.stringify(data),
				contentType: 'application/json; charset=utf-8',
				dataType: 'json'
			});
		}
	};

	r.Notify = {
		error: function notifyError(err, url, line){
			_notify(err);
			// only report bugsense for production code
			if(r.Bugsense && r.Event.STATUS.version.indexOf('readerVersion') === -1){
				var error = err;
				if(Object.prototype.toString.call(err) !== '[object Error]'){
					if(err && err.details && Object.prototype.toString.call(err.details) === '[object Error]'){
						error = err.details;
					} else {
						error = new Error(typeof err === 'string' ? err : JSON.stringify(err));
					}
				}
				var status = r.Event.getStatus();
				r.Bugsense.notify(error, url, line, {
					Progress: status.progress + '%',
					Page: status.page + '/' + status.pages,
					Chapter: status.chapter + '/' + status.chapters + ' - ' + (status.cfi ? status.cfi.chapter : 'Unknown chapter'),
					Bookmarks: status.bookmarks,
					Book_URL: r.DOCROOT,
					Book_Title: r.bookTitle,
					Book_ISBN: r.ISBN,
					CFI: status.cfi ? status.cfi.CFI : 'Unknown CFI',
					Preview: status.cfi ? status.cfi.preview : 'Unknown preview',
					Error: typeof err === 'string' ? err : JSON.stringify(err),
					Preferences: JSON.stringify(status.preferences),
					Layout: JSON.stringify(status.layout)
				});
			}
		},
		event: function notifyEvent(event){
			_notify(event);
		}
	};

	return r;

}(Reader || {}));
'use strict';

var Reader = (function (r) {

	var filters = new FilterJS(), HOOKS = {
		BEFORE_CHAPTER_PARSE: 'beforeChapterParse',
		BEFORE_CHAPTER_DISPLAY: 'beforeChapterDisplay'
	};

	// Build an absolute path from the relative path of a resource
	//
	// * `resourcePath` - relative path to the resource
	//
	// N.B. any relative path of a resource is relative to the containing document's place in the hierachary
	// Notes: relative path permutations (all of which must be handled)
	//
	// 1. Higher up the hierarchy e.g. `../../image.png"`
	// 2. Lower down int the hierarchy e.g. `/images/image.png`
	// 3. In the same hierarchy e.g. `image.png"`
	//
	// `CONTENT_PATH_PREFIX` represents a special case whereby there are path components present in the OPF file path e.g. `/OEPBS/content.opf` which is in turn should be inferred with any resource paths if they don't already exist in the resource path
	var _parseURL = function(resourcePath){
		var absoluteUrl = '',
			docName = r.Navigation.getChapterDocName(),
			docAbsPath = r.DOCROOT;

		// Absolute path of the document containing the image
		// TODO Move this to Chapter object? Maybe separate file?
		for (var i = 0; i < r.SPINE.length; i++) {
			var href = r.SPINE[i].href;
			if (href.indexOf(docName) !== -1) {
				// The document name was found.
				var pathComponents = href.split('/');
				if (href.indexOf(r.CONTENT_PATH_PREFIX) === -1) {
					// The href didn't contain the content path prefix (i.e. any path attached to the OPF file), so add it.
					docAbsPath += '/'+r.CONTENT_PATH_PREFIX.split('/')[0];
				}
				// Append the path components of the document to the absolute path (ignoring the path component which is the document name).
				if (pathComponents.length > 1) {
					for (var j = 0; j < pathComponents.length-1; j++) {
						docAbsPath += '/'+pathComponents[j];
					}
				}
			}
		}

		if (resourcePath.indexOf('../') === 0) {
			// Case 1 - resource is higher up the hierarchy e.g. `resourcePath = "../../image.png"` - You can find an example in *9780141918921 (Thinking, Fast and Slow)*
			try {
				var docPathComponents = docAbsPath.split('/');
				// Start at the second to the rightmost element document path component (we already know there's at least one '../' present
				var pathComponentIdx = docPathComponents.length-2;
				// Start at the index past the `../`
				var pos = 3;
				do {
					// Search resource path from left to right
					pos = resourcePath.indexOf('../', pos);
					if (pos !== -1) {
						pathComponentIdx--;
						// Skip past the `../`
						pos += 3;
					}
				} while (pos !== -1 );
				// Create the absolute path by using the absDocPath up to the target path component and then appending the resource path
				//
				// Locate the start of the target path component
				var startPos = docAbsPath.indexOf(docPathComponents[pathComponentIdx]);
				var length = docPathComponents[pathComponentIdx].length;
				absoluteUrl += docAbsPath.substring(0, startPos+length);
				// Add the resource path removing any leading `../`
				absoluteUrl += '/'+resourcePath.replace(/\.\.\//g, '');
			}
			catch (e) {
				console.log(e);
			}
		}
		else {
			// Case 2 - resource is lower down int the hierarchy e.g. `resourcePath = images/image.png` - You can find an example in *9781447213291 - The Prince who Walked with Lions*.
			//
			// Case 3 - resource is in the same hierarchy e.g. `resourcePath = "image.png"` - real example: *9781488508493 - Special Greats*.
			//
			// NOTE: docRoot has a trailing slash
			absoluteUrl = docAbsPath.charAt(docAbsPath.length-1) === '/' ? docAbsPath+resourcePath : docAbsPath+'/'+resourcePath;
		}

		// Calculate 95% of the width and height of the column.
		var width = Math.floor(r.Layout.Reader.width / r.Layout.Reader.columns - r.Layout.Reader.padding / 2);
		var height = Math.floor(r.Layout.Reader.height);
		return absoluteUrl.replace('params;', 'params;img:w='+width+';img:h='+height+';img:m=scale;');
	};

	// add data attributes to anchors
	var _anchorData = function($content){

		$('a[href]', $content).each(function(i, link){
			var $link = $(link);
			var valid = /^(ftp|http|https):\/\/[^ "]+$/.test($link.attr('href'));
			if (!valid) {
				// ### Internal link.
				$link.attr('data-link-type', 'internal');
				/* elements[idx].attributes[0].nodeValue = 'http://localhost:8888/books/9780718159467/OPS/xhtml/' + elements[idx].attributes[0].nodeValue;*/
			} else {
				// ### External link.
				// External links attribute 'target' set to '_blank' for open the new link in another window / tab of the browser.
				$link.attr('data-link-type', 'external').attr('target', '_blank');
			}
		});

		return $content;
	};

	// Rebuild image src
	var _parseImages = function(content){
		// Transform relative image resource paths to absolute
		var images = content.getElementsByTagName('img');
		if (images.length === 0) {
			images = content.getElementsByTagName('IMG');
		}
		// Check if the img tag is a SVG or not as Webkit and IE10 change the tag name.
		for (var i = 0, image = images[i]; image; image = images[++i]) {
			if (image.hasAttribute('src')) {
				var imgSrc = _parseURL(image.getAttribute('src'));
				// Prevent premature loading of img elements:
				image.setAttribute('data-src', imgSrc);
				// Use a tiny data-uri GIF as placeholder:
				image.setAttribute('src', 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs%3D');
			}
		}
		return content;
	};

	// Modify SVG images URL and put it in a new IMG element.
	var _parseSVG = function(content){
		var svg = content.getElementsByTagNameNS('http://www.w3.org/2000/svg', 'svg');
		if (svg.length === 0) { // Just in case the tags are not in the NS format
			svg = content.getElementsByTagName('svg');
		}
		if (svg) {
			for (var j = 0; j < svg.length; j++) {
				var img = svg[j].getElementsByTagNameNS('http://www.w3.org/2000/svg', 'image')[0];
				if (img === undefined) {
					// Check if the tag is IMG
					img = svg[j].getElementsByTagName('img')[0];
				}
				if (img === undefined) {
					// Check if the tag is IMAGE but it does not have Namespace
					img = svg[j].getElementsByTagName('image')[0];
				}
				if (img) {
					if (img.hasAttributeNS('http://www.w3.org/1999/xlink', 'href')) {
						var url = img.getAttributeNS('http://www.w3.org/1999/xlink', 'href');
						url = _parseURL(url);
						// Replace the svg tag if it is an image and show it in a normal IMG tag (compatible with SVG image format)
						var newImg = document.createElement('img');
						newImg.setAttribute('src', url);
						// TODO Firefox max-width fix
						// newImg.style.maxWidth = 95 / 100 * Math.floor(r.Layout.Reader.width / r.Layout.Reader.columns - r.Layout.Reader.padding / 2) + 'px';
						var parentNode = svg[j].parentNode;
						parentNode.insertBefore(newImg,svg[j]);
						parentNode.removeChild(svg[j]);
					}
				}
			}
		}
		return content;
	};

	// Modify video URL.
	var _parseVideos = function(content){
		var videos = content.getElementsByTagName('video');
		for (var y = 0; y < videos.length; y++) {
			var vidSrc = videos[y].getAttribute('src');
			vidSrc = _parseURL(vidSrc);
			videos[y].setAttribute('src', vidSrc);
		}
		return content;
	};


	// helper function that strips the last path from the url
	// Ex: a/b/c.html -> a/b
	var _removeLastPath = function(url){
		var pathSeparatorIndex = url.lastIndexOf('/');
		return pathSeparatorIndex !== -1 ? url.substring(0, pathSeparatorIndex) : url;
	};

	// Function to transform relative links
	// ex: `../html/chapter.html` -> `chapter.html`
	var _normalizeLink = function(url){
		// get current chapter folder url
		var chapter = r.Navigation.getChapter(), chapterURL = _removeLastPath(r.SPINE[chapter].href), result = chapterURL;

		// parse current url to remove `..` from path
		var paths = url.split('/');
		for(var i = 0, l = paths.length; i < l; i++){
			var path = paths[i];
			if(path === '..'){
				result = _removeLastPath(result);
			} else {
				result += '/' + path;
			}
		}
		return result;
	};

	var _parseAnchors = function(content){
		var anchors = content.getElementsByTagName('a');
		for (var y = 0; y < anchors.length; y++) {
			var href = anchors[y].getAttribute('href');
			if(href){
				href = _normalizeLink(href);
				anchors[y].setAttribute('href', href);
			}
		}
		return content;
	};

	// Register all the anchors.
	filters.addFilter(HOOKS.BEFORE_CHAPTER_DISPLAY, _anchorData);
	filters.addFilter(HOOKS.BEFORE_CHAPTER_PARSE, _parseImages);
	filters.addFilter(HOOKS.BEFORE_CHAPTER_PARSE, _parseAnchors);
	filters.addFilter(HOOKS.BEFORE_CHAPTER_PARSE, _parseSVG);
	filters.addFilter(HOOKS.BEFORE_CHAPTER_PARSE, _parseVideos);

	r.Filters = $.extend({HOOKS: HOOKS}, filters);

	return r;
}(Reader || {}));

'use strict';

/* jshint unused: true */
/* exported Reader */

// The **Formatting** options available to the user.
//
// * [`setLineHeight`](#setLineHeight)
// * [`increaseLineHeight`](#increaseLineHeight)
// * [`decreaseLineHeight`](#decreaseLineHeight)
// * [`setFontSize`](#setFontSize)
// * [`setTextAlign`](#setTextAlign)
// * [`setFontFamily`](#setFontFamily)
// * [`increaseFontSize`](#increaseFontSize)
// * [`decreaseFontSize`](#decreaseFontSize)
// * [`setMargin`](#setMargin)
// * [`setTheme`](#setTheme)

var Reader = (function (r) {
	// <a name="setLineHeight"></a>Set line size, if within bounds.
	// If current line height is larger than the minimum line height, decrease it by one unit.
	// Returns the current value of the line height
	r.setLineHeight = function(value){
		return r.setPreferences({lineHeight: value});
	};

	// <a name="increaseLineHeight"></a>Increase line size, if possible
	// If current line height is smaller than the maximum line height, increase it by one unit.
	// ReturnS the current value of the line height.
	r.increaseLineHeight = function(){
		return r.setPreferences({lineHeight: r.preferences.lineHeight.value + r.preferences.lineHeight.unit});
	};

	// <a name="decreaseLineHeight"></a>Decrease line size, if possible.
	// If current line height is larger than the minimum line height, decrease it by one unit.
	// Returns the current value of the line height.
	r.decreaseLineHeight = function(){
		return r.setPreferences({lineHeight: r.preferences.lineHeight.value - r.preferences.lineHeight.unit});
	};

	// <a name="setFontSize"></a>Set font size, if within bounds.
	// If current font size is larger than the minimum font, decrease it by one unit.
	// Returns the current value of the line height.
	r.setFontSize = function(value){
		return r.setPreferences({fontSize: value});
	};

	// <a name="setTextAlign"></a>Set the text alignment, acceptable values are only left or justified.
	// If the argument is different than the acceptable values, defaults to left.
	// Return the current value of the text align.
	r.setTextAlign = function(value){
		return r.setPreferences({textAlign: value});
	};

	// <a name="setFontFamily"></a>Set font family
	// Return the current font-family of the reader.
	r.setFontFamily = function(value){
		return r.setPreferences({fontFamily: value});
	};

	// <a name="increaseFontSize"></a>Increase font size, if possible.
	// If current font size is smaller than the maximum font size, increase it by one unit.
	// Returns the current value of the font size.
	r.increaseFontSize = function(){
		return r.setPreferences({fontSize: r.preferences.fontSize.value + r.preferences.fontSize.unit});
	};

	// <a name="decreaseFontSize"></a>Decrease font size, if possible
	// If current font size is larger than the minimum font size, decrease it by one unit
	// Returns the current value of the font size
	r.decreaseFontSize = function(){
		return r.setPreferences({fontSize: r.preferences.fontSize.value - r.preferences.fontSize.unit});
	};

	// <a name="setMargin"></a>Setter for the reader's margin property
	//
	// * `args` an array of 4 integers representing the top, right, bottom, left margins. Can also accept keyword params such as 'min', 'max' and 'medium'.
	// Returns the updated margins.
	r.setMargin = function(args){
		return r.setPreferences({margin:args});
	};

	// <a name="setTheme"></a>Setter for the reader's theme
	//
	// * `args` an object containing the color and background of the theme. Can also accept keyword params such as 'light', 'dark' and 'sepia'
	// Returns the current theme
	r.setTheme = function(args){
		return r.setPreferences({theme:args});
	};

	// <a name="setPreferences"></a>Set all style related user preferences
	//
	// * `args` an Object containing valid preference values.

	r.setPreferences = function(args){
		if(typeof args === 'object'){
			var value, updated = false;

			// Set line height if all conditions are met
			if(args.hasOwnProperty('lineHeight')){
				value = parseFloat(args.lineHeight) || r.preferences.lineHeight.value;
				if(r.preferences.lineHeight.value !== value && r.preferences.lineHeight.max >= value && r.preferences.lineHeight.min <= value){
					r.preferences.lineHeight.value = value;
					updated = true;
				}
			}

			if(args.hasOwnProperty('fontSize')){
				value = parseFloat(args.fontSize) || r.preferences.fontSize.value;
				if(r.preferences.fontSize.value !== value && r.preferences.fontSize.max >= value && r.preferences.fontSize.min <= value){
					r.preferences.fontSize.value = value;
					updated = true;
				}
			}

			if(args.hasOwnProperty('textAlign')){
				value = r.preferences.textAlign.clear(args.textAlign);
				if(r.preferences.textAlign.value !== value){
					r.preferences.textAlign.value = value;
					updated = true;
				}
			}

			if(args.hasOwnProperty('fontFamily')){
				value = typeof(args.fontFamily) === 'string' ? args.fontFamily : r.preferences.fontFamily.value;
				if(r.preferences.fontFamily.value !== value){
					r.preferences.fontFamily.value = value;
					updated = true;
				}
			}

			if(args.hasOwnProperty('margin')){
				value = r.preferences.margin.clear(args.margin);
				if(value !== r.preferences.margin.value){
					r.preferences.margin.value = value;
					r.resizeContainer();
					updated = true;
				}
			}

			if(args.hasOwnProperty('theme')){
				value = r.preferences.theme.clear(args.theme);
				if(value !== r.preferences.theme.value){
					r.preferences.theme.value = value;
					updated = true;
				}
			}

			if(updated){
				r.preferences.applyAll();

				// Update variables that are dependant on styles.
				r.refreshLayout();
			}
		}
		return r.preferences;
	};
	return r;
}(Reader || {}));

'use strict';

var Reader = (function (r) {

	r.resizeContainer = function(dimensions){
		dimensions = $.extend({
			width: r.Layout.Container.width,
			height: r.Layout.Container.height,
			columns: r.Layout.Reader.columns,
			padding: r.Layout.Reader.padding
		}, dimensions);

		// Save new values.
		r.Layout.Container.width = Math.floor(dimensions.width);
		r.Layout.Container.height = Math.floor(dimensions.height);
		r.Layout.Reader.width = r.Layout.Container.width - Math.floor(r.preferences.margin.value[1]*r.Layout.Container.width/100) - Math.floor(r.preferences.margin.value[3]*r.Layout.Container.width/100);
		r.Layout.Reader.height = r.Layout.Container.height - Math.floor(r.preferences.margin.value[0]*r.Layout.Container.height/100) - Math.floor(r.preferences.margin.value[2]*r.Layout.Container.height/100);
		r.Layout.Reader.columns = dimensions.columns;
		r.Layout.Reader.padding = dimensions.columns > 1 ? dimensions.padding : 0; // only set padding on multi-column layout

		// avoid rounding errors, adjust the width of the reader to contain the columns + padding
		var columnWidth = Math.floor(r.Layout.Reader.width / r.Layout.Reader.columns - r.Layout.Reader.padding / 2);
		r.Layout.Reader.width = columnWidth * r.Layout.Reader.columns + (r.Layout.Reader.columns - 1) * r.Layout.Reader.padding;

		// Apply new size
		r.$iframe.css({
			width: r.Layout.Container.width + 'px',
			height: r.Layout.Container.height + 'px'
		});

		r.$reader.css({
			width: r.Layout.Reader.width + 'px',
			height: r.Layout.Reader.height + 'px',
			'column-width': columnWidth + 'px',
			'column-gap': r.Layout.Reader.padding + 'px',
			'column-fill': 'auto'
		});

		r.$container.css({
			width: r.Layout.Reader.width + 'px',
			height: r.Layout.Reader.height + 'px',
			'margin-left': Math.floor(r.preferences.margin.value[3] * r.Layout.Container.width/100) + 'px',
			'margin-right': Math.floor(r.preferences.margin.value[1] * r.Layout.Container.width/100) + 'px'
		});

		r.$header.css({
			width: r.Layout.Reader.width + 'px',
			'margin-left': Math.floor(r.preferences.margin.value[3] * r.Layout.Container.width/100) + 'px',
			'margin-right': Math.floor(r.preferences.margin.value[1] * r.Layout.Container.width/100) + 'px',
			'height': Math.floor(r.preferences.margin.value[0] * r.Layout.Container.height/100) + 'px',
			'line-height': Math.floor(r.preferences.margin.value[0] * r.Layout.Container.height/100) + 'px'
		});

		r.$footer.css({
			width: r.Layout.Reader.width + 'px',
			'margin-left': Math.floor(r.preferences.margin.value[3] * r.Layout.Container.width/100) + 'px',
			'margin-right': Math.floor(r.preferences.margin.value[1] * r.Layout.Container.width/100) + 'px',
			'height': Math.floor(r.preferences.margin.value[2] * r.Layout.Container.height/100) + 'px',
			'line-height': Math.floor(r.preferences.margin.value[2] * r.Layout.Container.height/100) + 'px'
		});

		_resizeImages();
		// Update navigation variables
		r.refreshLayout();
	};

	// Modifies some parameter related to the dimensions of the images and svg elements.
	var _resizeImages = function(){
		// Get SVG elements
		$('svg', r.$reader).each(function(index,node){
			// Calculate 95% of the width and height of the container.
			var width = Math.floor(0.95 * (r.Layout.Reader.width / r.Layout.Reader.columns - r.Layout.Reader.padding / 2));
			var height = Math.floor(0.95 * r.Layout.Reader.height);
			// Modify SVG params when the dimensions are higher than the view space or they are set in % as this unit is not working in IE.
			if ((node.getAttribute('width') && (node.getAttribute('width') > r.Layout.Reader.width || node.getAttribute('width').indexOf('%') !== -1)) || !node.getAttribute('width')) {
				node.setAttribute('width', width);
			}
			if ((node.getAttribute('height') && (node.getAttribute('height') > r.Layout.Reader.height || node.getAttribute('height').indexOf('%') !== -1)) || !node.getAttribute('height')) {
				node.setAttribute('height', height);
			}
			// Modify the viewBox attribute if their dimensions are higher than the container.
			node.viewBox.baseVal.width = (node.viewBox.baseVal.width > r.Layout.Reader.width) ? width : node.viewBox.baseVal.width;
			node.viewBox.baseVal.height = (node.viewBox.baseVal.height > r.Layout.Reader.height) ? height : node.viewBox.baseVal.height;
			node.setAttribute('transform', 'scale(1)');
			// Modify children elements (images, rectangles, circles..) dimensions if they are higher than the container.
			$(this).children().map(function(){
				if ($(this).attr('width') > r.Layout.Reader.width) {
					$(this).attr('width', width);
				}
				if ($(this).attr('height') > r.Layout.Reader.height) {
					$(this).attr('height', height);
				}
			});
			if ($(this).find('path')) {
				// Fix path elements dimensions.
				var pathMaxWidth = 0;
				var pathMaxHeight = 0;
				// Take the highest width and height.
				$(this).find('path').each(function(){
					var pathWidth = $(this)[0].getBoundingClientRect().width;
					var pathHeight = $(this)[0].getBoundingClientRect().height;
					pathMaxWidth = (pathWidth > pathMaxWidth) ? pathWidth : pathMaxWidth;
					pathMaxHeight = (pathHeight > pathMaxHeight) ? pathHeight : pathMaxHeight;
				});
				if (pathMaxWidth > width || pathMaxHeight > height) {
					// Scale the elements to the correct proportion.
					var scale = Math.min(Math.floor((width/pathMaxWidth)*10)/10,Math.floor((height/pathMaxHeight)*10)/10);
					$(this).find('path').each(function(){
						$(this)[0].setAttribute('transform', 'scale(' + scale + ')');
					});
				}
			}
			// Remove SVG empty elements in some Webkit browsers is showing the content outside the SVG (Chrome).
			if ($(this).children().length === 0) {
				$(this).remove();
			}
		});
	};

	return r;
}(Reader || {}));

'use strict';

/* jshint unused: true */
/* exported Reader */
/* global $ */

var Reader = (function (r) {

	r.SPINE = [];

	// Number of chapters.
	var bookChapters = 0;
	// Initial chapter by default.
	var chapter = 0;
	// Initial page by default.
	var page = 0;
	// Number of pages in the actual chapter (columns number).
	var pagesByChapter = 0;
	// The current location's CFI.
	var _cfi = null;

	var chapterDocName = '';

	// Reset method for the reader.
	// *Note, some properties are not reset, such as preferences, listeners, styling*.
	r.reset = function(){
		r.INF = 'META-INF/book-info.json';
		r.CONTENT_PATH_PREFIX = '';
		r.OPF = '';
		r.SPINE = [];
		r.TOC = [];
		r.opf = null;
		r.DOCROOT = '';
		r.sample = false;
		r.mobile = false;
		r.bookTitle = '';
		r.bookAuthor = '';

		// Reset all modules.
		r.CFI.reset();
		r.Navigation.reset();
		r.Bookmarks.reset();

		// Remove book content.
		if(r.$parent){
			r.$parent.empty();
			r.$iframe = null;
			r.$wrap = null;
			r.$head = null;
			r.$container = null;
			r.$reader = null;
			r.$header = null;
			r.$footer = null;
			r.$stylesheet = null;

			// reset link to CSS rules
			r.preferences.lineHeight.rules = [];
			r.preferences.fontSize.rules = [];
			r.preferences.fontFamily.rules = [];
			r.preferences.textAlign.rules = [];
			r.preferences.theme.rules = {
				background: [],
				title: [],
				color: []
			};
		}
	};

	r.getReaderLeftPosition = function () {
	  // Transform value is matrix(a, c, b, d, tx, ty)
	  return parseInt(r.$reader.css('transform').split(',')[4], 10) || 0;
	};

	r.setReaderLeftPosition = function (pos) {
	  r.$reader.css('transform', 'translateX(' + pos + 'px)');
	};

	// Return the page number in the actual chapter where it is an element.
	r.moveToAnchor = function (id) {
		// Find the obj
		var obj = $(r.$iframe.contents()[0].getElementById(String(id)));
    if (obj.length === 0) {
      return 0; // If the object does not exist in the chapter we send the user to the page 0 of the chapter
    } else {
      // Check if the element has children and send the first one. This is to avoid the problems with big elements, like a wrapper for all the chapter.
      if (obj.children().length > 0) {
        return r.returnPageElement(obj.children().first());
      }
      return r.returnPageElement(obj);
    }
	};

	// Returns the page number related to an element.
	// [27.11.13] Refactored how we calculate the page for an element. Since the offset is calculated relative to the reader container now, we don't need to calculate the relative page number, only the absolute one.
	r.returnPageElement = function(obj) {
    obj = (obj instanceof $) ? obj : $(obj, r.$iframe.contents());
		var offset = obj.offset().left - r.$reader.offset().left;
		return Math.floor((offset) / Math.floor(r.Layout.Reader.width + r.Layout.Reader.padding));
	};

	var _getColumnsNumber = function() {
		var el = r.$reader[0];
		// we el.scrollWidth remove 1 pixel from scroll width to return the correct number of pages when the scroll width === the column width (other wise return one extra page)
		return Math.floor((el.scrollWidth - 1) / Math.floor(r.Layout.Reader.width + r.Layout.Reader.padding));
	};

	// Refresh the content layout.
	r.refreshLayout = function(){
		// Update the number of columns
		pagesByChapter = _getColumnsNumber();

		var promise;
		// Maintain reader current position
		if(_cfi && _cfi.CFI) {
			promise = r.CFI.goToCFI(_cfi.CFI, true);
		} else {
			promise = $.Deferred().resolve().promise();
		}
		promise.then(function () {
			r.Bookmarks.display();
			r.Navigation.updateProgress();
		});
	};

	// The current book progress.
	var _progress = 0;
	var _totalWordCount = -1;

	// ## Navigation API
	// The Navigation object exposes methods to allow the user to navigate within the book.
	//
	// * `save`
	// * `setNumberOfChapters`
	// * `getPage`
	// * `setPage`
	// * `loadPage`
	// * `setNumberOfPagesInChapter`
	// * `setChapter`
	// * `getChapter`
	// * `getChapterDocName`
	// * `loadChapter`
	// * `next`
	// * `prev`
	// * `getCFI`
	// * `getCFIObject`
	// * `setCFI`
	// * `reset`
	// * `getProgress`
	// * `updateProgress`
	// * `getCurrentCFI`
	// * `updateCurrentCFI`
	// * `update`

	r.Navigation = {
		save: function(){
			/* for(var k in sLoad) { oLoad[k]=sLoad[k]; } */
		},
		setNumberOfChapters: function(numberOfChapters) {
			bookChapters = numberOfChapters;
		},
		getNumberOfChapters: function(){
			return Chapter.getTotal();
		},
		getPage: function() {
			return Page.get();
		},
		getNumberOfPages: function(){
			return Page.getByChapter();
		},
		setNumberOfPages: function(){
			// Update the number of columns
			pagesByChapter = _getColumnsNumber();
		},
		setPage: function(p) {
			Page.set(p);
		},
		loadPage: function(p, fixed) {
			return Page.load(p, fixed);
		},
		setChapter: function(c){
			chapter = c;
			// Update the chapter doc name.
			try {
				var pathComponents = r.SPINE[chapter].href.split('/');
				// get the last element in the array
				chapterDocName = pathComponents.slice(-1)[0];
			}
			catch (e) {
				console.log('setChapter:'+e);
			}
		},
		getChapter: function(){
			return Chapter.get();
		},
		getChapterDocName: function() {
			return Chapter.getDocName();
		},
		loadChapter: function(url){
			/* TODO refactor with checkURL has they share code */
			var u = url.split('#')[0];
			var a = url.split('#')[1];
			if(u.indexOf('/') !== -1) {
				// Take only the file name from the URL.
				u = u.substr(u.lastIndexOf('/') + 1);
			}
			// Check the spine
			for (var j=0; j<r.SPINE.length;j++) {
				// URL is in the Spine and it has a chapter number.
				if (r.SPINE[j].href.indexOf(u) !== -1) {
					r.Navigation.setChapter(j);
					return r.loadAnchor(j,a);
				}
			}

			// Chapter does not exist
			var defer = $.Deferred();
			defer.reject($.extend({}, r.Event.ERR_INVALID_ARGUMENT, {details: 'Specified chapter does not exist.', call: 'loadChapter'}));
			return defer.promise();
		},
		next: function() {
			if (page < pagesByChapter) {
				return Page.next();
			}
			var defer = $.Deferred();
			if (chapter < bookChapters - 1) {
			  defer.notify();
			  Chapter.load(Chapter.next()).then(function chapterLoadCallback(){
			    r.Navigation.loadPage(0).then(defer.resolve, defer.reject);
			  }, defer.reject);
			} else {
			  defer.reject(r.Event.END_OF_BOOK);
			}
			return defer.promise();
		},
		prev: function() {
			if (page > 0) {
				return Page.prev();
			}
			var defer = $.Deferred();
			if (chapter > 0) {
			  defer.notify();
			  Chapter.load(Chapter.prev()).then(function chapterLoadCallback(){
			    r.Navigation.loadPage('LASTPAGE').then(defer.resolve, defer.reject);
			  }, defer.reject);
			} else {
			  defer.reject(r.Event.START_OF_BOOK);
			}
			return defer.promise();
		},
		setCFI: function(cfi){
			if (!cfi) {
				cfi = r.CFI.getCFIObject();
			}
			r.CFI.setCFI(cfi);
		},
		reset: function(){
			bookChapters = 0;
			chapter = 0;
			page = 0;
			pagesByChapter = 0;
			_cfi = null;
			_totalWordCount = -1;
			_progress = 0;
		},
		getProgress: function(){
			return _progress;
		},
		updateProgress: function(){
			var i = 0;
			// Update total number of words in the book, if not already done.
			if(_totalWordCount === -1 && r.SPINE.length){
				_totalWordCount = 0;
				for(i = 0; i < r.SPINE.length; i++){
					_totalWordCount += r.SPINE[i].linear ? r.SPINE[i].wordCount : 0;
				}
			}

			// Get word count of all previous chapters.
			var currentWordCount = 0;
			for(i = 0; i < chapter; i++){
				currentWordCount += r.SPINE[i].linear ? r.SPINE[i].wordCount : 0;
			}

			// Estimate red word count from current chapter. To avoid 0 based indexes and adding +1
			currentWordCount += r.SPINE.length && r.SPINE[chapter].linear ? r.SPINE[chapter].wordCount * (page+1) / (pagesByChapter+1) : 0;

			// Calculate progress.
			var progress = Math.floor(currentWordCount / _totalWordCount * 100);
			// If the progress has a valid value (is a number) AND it is different than the current one, update it and send an event notification.
			if(progress !== _progress && !isNaN(progress)){
				_progress = progress;
				// Send notification to all listeners that the progress has been updated
				// r.execEvent(r.Event.PROGRESS_UPDATED);
			}

			if (r.mobile) {
				// Update footer and display progress.
				var progressContainer = $('#cpr-progress', r.$iframe.contents());
				if(!progressContainer.length){
					progressContainer = $('<div id="cpr-progress"></div>').appendTo(r.$footer);
				}
				if (r.sample) {
					progressContainer.text(_progress+' % of sample');
				} else {
					progressContainer.text(_progress+' % read');
				}
			}
		},
		getCurrentCFI: function(){
			return _cfi;
		},
		updateCurrentCFI: function(){
			_cfi = r.CFI.getCFIObject();
		},
		update: function(){
			r.Navigation.updateCurrentCFI();
			r.Navigation.updateProgress();
			r.Bookmarks.display();
		}
	};

	function loadImages(reverse) {
	  var images = $('img', r.$reader),
		    mainDefer = $.Deferred(),
	      promise = $.Deferred().resolve().promise();
		if (images.length && reverse) {
			images = $(images.get().reverse());
		}
		images.each(function () {
	    var el = this,
	        dataSrc = el && el.getAttribute('data-src');
	    if (!dataSrc) {
	      return;
	    }
	    // Load images sequentially so we only load images until the nearest pages are filled:
	    promise = promise.then(function () {
	      if (Math.abs(r.returnPageElement(el) - r.Navigation.getPage()) < 2) {
	        var defer = $.Deferred();
	        $(el).one('load error', function () {
		        // All images greater than 75% of the reader width will receive cpr-center class to center them:
		        if (el.width > 3/4*(r.Layout.Reader.width / r.Layout.Reader.columns - r.Layout.Reader.padding / 2)) {
			        $(el).addClass('cpr-center');
		        }
		        // Notify on each image load:
		        mainDefer.notify({type: 'load.img', element: el});
	          defer.resolve();
	        });
	        el.setAttribute('src', dataSrc);
	        el.removeAttribute('data-src');
	        return defer.promise();
	      }
	    });
	  });
		promise.then(function () {
			mainDefer.resolve();
		});
	  return mainDefer.promise();
	}

	// ## Page API
	// Actual page is contained in the variable _pageIndex.
	//
	// * `get` returns the index of the actual page.
	// * `getByChapter` return the total number of pages in the actual chapter.
	// * `next` refreshes the page variable adding one and moves to the next page (column)
	// * `prev` refreshes the page variable subtracting one and moves to the prev pave (column)
	// * `load` refreshes the page variable with a value and moves the scroll to its position
	var Page = {
		set: function(p) {
			page = p;
		},
		get: function() {
			return page;
		},
		getByChapter: function() {
			return pagesByChapter;
		},
		next: function() {
			page = page + 1;
			var readerOuterWidth = Math.floor(r.Layout.Reader.width + r.Layout.Reader.padding);
			r.setReaderLeftPosition(r.getReaderLeftPosition() - readerOuterWidth);
			r.Navigation.updateCurrentCFI();
			return loadImages().then(function () {
			  r.refreshLayout();
			});
		},
		prev: function() {
			page = page - 1;
			var readerOuterWidth = Math.floor(r.Layout.Reader.width + r.Layout.Reader.padding);
			r.setReaderLeftPosition(r.getReaderLeftPosition() + readerOuterWidth);
			r.Navigation.updateCurrentCFI();
			return loadImages(true).then(function () {
			  r.refreshLayout();
			});
		},
		// Moves to the page given as index, epubcfi, anchor or special page "LASTPAGE":
		moveTo: function (p) {
			if (p === 'LASTPAGE') {
				// page is given as "LASTPAGE", jump to the last page of the chapter:
				page = pagesByChapter;
			} else if ($.type(p) === 'string') {
				if (/^epubcfi\(.+\)$/.test(p)) {
					// page is given as CFI, jump to the page containing the CFI marker:
					var pos = r.CFI.findCFIElement(p);
					page = pos === -1 ? 0 : pos;
				} else {
					// page is given as element id, jump to the page containing the element:
					page = r.moveToAnchor(p);
				}
			} else {
				page = p || 0;
			}
			r.setReaderLeftPosition(-1 * Math.floor(r.Layout.Reader.width + r.Layout.Reader.padding) * page);
		},
		load: function(p, fixed) {
			Page.moveTo(p);
			var promise = loadImages(p === 'LASTPAGE')
				.progress(function () {
					// Update the colums and page position on each image load:
					pagesByChapter = _getColumnsNumber();
					Page.moveTo(p);
				});
			if (!fixed) {
				promise = promise.then(function () {
					r.Navigation.update();
				});
			}
			return promise;
		}
	};

	// ## Chapter API
	// Chapters number is contained in the variable _bookChapters.
	// Chapter index is controlled with the _bookChapter variable.
	//
	// * `get` returns the index of the actual chapter (_bookChapter)
	// * `getTotal` returns the total number of pages in the actual chapter.
	// * `next` refresh the index variable adding one.
	// * `prev` refresh the index variable subtracting one.
	var Chapter = {
		get: function(callback) {
			if (callback && typeof(callback) === 'function') { callback(); }
			return chapter;
		},
		getDocName: function(callback) {
			if (callback && typeof(callback) === 'function') { callback(); }
			return chapterDocName;
		},
		getTotal: function(callback) {
			if (callback && typeof(callback) === 'function') { callback(); }
			return bookChapters;
		},
		next: function() {
			return ++chapter;
		},
		prev: function() {
			return --chapter;
		},
		load: function(c) {
			return r.loadChapter(c);
		}
	};

	return r;

}(Reader || {}));

/**
 * ReaderJS v1.0.0
 * (c) 2013 BlinkboxBooks
 * parse.js: methods to parse and clean the content
 */

'use strict';

var Reader = (function (r) {

	// Parses the content according its mimetype. Returns the parsed content
	//
	// * `content` The content of the document
	// * `mimetype` The MIME type of the given document
	r.parse = function (content, mimetype) {
		// Replace images and styles URLs.

		switch (mimetype) {
		case 'application/xhtml+xml':
			content = parseXHTML(content);
			break;
		default:
			break;
		}
		// Extract the contents of the body only thus ignoring any styles declared in head
		return typeof content === 'string' ? $(content.split(/<body[^>]*>/)[1].split('</body>')[0]) : null;
	};

	// Parses the content in application/xhtml+xml. Returns the parsed content.
	//
	// * `content` The content of the document
	var parseXHTML = function (content) {
		var parser = new DOMParser();
		if (content.indexOf('<!-- livereload snippet -->') !== -1) {
			// Delete livereload script tags (added by grunt to html files)
			content = content.split('<!-- livereload snippet -->')[0].trim() + '</body></html>';
		}

		var object = parser.parseFromString(content, 'application/xhtml+xml');
		if(object.getElementsByTagName('parsererror').length > 0){
			// TODO Refactor
			// Parsing failures should be handled differently than just sending an error to the client
			r.Notify.error(r.Event.ERR_PARSING_FAILED);
		}

		object = r.Filters.applyFilters(r.Filters.HOOKS.BEFORE_CHAPTER_PARSE, object);

		var prefixes = [];
		// Get all elements in any namespace.
		var elements = object.getElementsByTagNameNS('*', '*');

		var html = '<!DOCTYPE html>\n<html>' + object.documentElement.innerHTML + '</html>';
		// Remove the prefix in those that have.
		for (var k = 0; k < elements.length; k++) {
			if (elements[k].prefix) {
				prefixes[elements[k].prefix] = {prefix: elements[k].prefix, uri: elements[k].namespaceURI};
			}
		}

		// Search all prefixes in the code and remove them, also search the declaration of this prefix and also eliminates them.
		for (var x in prefixes) {
			var prefix = prefixes[x].prefix;
			var uri = prefixes[x].uri;
			// Patterns to search the prefixes and their namespace declarations.
			var pattern_open = new RegExp('<' + prefix + ':', 'g');
			var pattern_close = new RegExp('<\/' + prefix + ':', 'g');
			var namespaceURI = new RegExp('xmlns:' + prefix + '=\"' + uri + '\"', 'g');

			html = html.replace(pattern_open, '<');
			html = html.replace(pattern_close, '</');
			html = html.replace(namespaceURI, '');
		}
		return html;
	};

	return r;

}(Reader || {}));
'use strict';

/* jshint unused: true */
/* exported Reader */

var Reader = (function (r) {

	r.hideHeaderAndFooter = function(){
		r.$header.css({visibility: 'hidden'});
		r.$footer.css({visibility: 'hidden'});
	};

	r.showHeaderAndFooter = function(){
		r.$header.css({visibility: 'visible'});
		r.$footer.css({visibility: 'visible'});
	};

	return r;
}(Reader || {}));

'use strict';
/* exported READER */
/* globals $, Reader */
var READER = (function() {
	// Public methods from the Reader.
	// All client communication is done here and only here. Do NOT send any events from other files.
	// The reader should return a promise for any action, a promise that gets resolved/rejected and the appropriate event is fired when the promise is fulfiled.
	// The goal is to make the reader as client-ignorant as possible.

	// Generates an object summarizing the reader status.
	var _send_status = function(call){
		Reader.Notify.event($.extend({}, Reader.Event.getStatus(), {
			'call': call || ''
		}));
	};

	// Wrap a reader action so that it will return the reader status after the action is performed
	var _status_wrap = function(action, call){
		return function(){
			var result = action.apply(null, arguments);
			_send_status(call);
			return result;
		};
	};

	return {
		init: function init(){
			return Reader.init.apply(Reader, arguments).always(function initComplete(){
				Reader.Notify.event(Reader.Event.LOADING_COMPLETE);
			}).then(function initSuccess(){
					_send_status('init');
				}, function initFailure(err){
					Reader.Notify.error(err);
				}, function initNotify(){
					Reader.Notify.event(Reader.Event.LOADING_STARTED);
				}
			);
		},
		setLineHeight: _status_wrap(Reader.setLineHeight, 'setLineHeight'),
		increaseLineHeight: _status_wrap(Reader.increaseLineHeight, 'increaseLineHeight'),
		decreaseLineHeight: _status_wrap(Reader.decreaseLineHeight, 'decreaseLineHeight'),
		increaseFontSize: _status_wrap(Reader.increaseFontSize, 'increaseFontSize'),
		decreaseFontSize: _status_wrap(Reader.decreaseFontSize, 'decreaseFontSize'),
		setFontSize: _status_wrap(Reader.setFontSize, 'setFontSize'),
		setTextAlign: _status_wrap(Reader.setTextAlign, 'setTextAlign'),
		setMargin: _status_wrap(Reader.setMargin, 'setMargin'),
		setTheme: _status_wrap(Reader.setTheme, 'setTheme'),
		setFontFamily: _status_wrap(Reader.setFontFamily, 'setFontFamily'),
		setPreferences: _status_wrap(Reader.setPreferences, 'setPreferences'),
		getCFI: Reader.CFI.getCFI,
		goToCFI: function goToCFI(){
			Reader.Notify.event(Reader.Event.LOADING_STARTED);
			return Reader.CFI.goToCFI.apply(Reader.CFI, arguments).always(function goToCFIComplete(){
				Reader.Notify.event(Reader.Event.LOADING_COMPLETE);
				_send_status('goToCFI');
			});
		},
		next: function next(){
			var _loading_required = false;
			return Reader.Navigation.next().always(function nextComplete(){
				if(_loading_required){
					Reader.Notify.event(Reader.Event.LOADING_COMPLETE);
				}
			}).then(
				function nextOnSuccess(){
					_send_status('next');
				}, function nextOnError(err){
					if(err === Reader.Event.END_OF_BOOK || err === Reader.Event.START_OF_BOOK){
						Reader.Notify.event(err);
					} else {
						Reader.Notify.error(err);
					}
				}, function nextOnNotification(args){
					if (args && args.type === 'load.img') {
						return;
					}
					// book requires remote file, send a loading event to notify the client
					Reader.Notify.event(Reader.Event.LOADING_STARTED);
					_loading_required = true;
				}
			);
		},
		prev: function next(){
			var _loading_required = false;
			return Reader.Navigation.prev().always(function prevComplete(){
				if(_loading_required){
					Reader.Notify.event(Reader.Event.LOADING_COMPLETE);
				}
			}).then(
				function prevOnSuccess(){
					_send_status('prev');
				}, function prevOnError(err){
					if(err === Reader.Event.END_OF_BOOK || err === Reader.Event.START_OF_BOOK){
						Reader.Notify.event(err);
					} else {
						Reader.Notify.error(err);
					}
				}, function prevOnNotification(args){
					if (args && args.type === 'load.img') {
						return;
					}
					// book requires remote file, send a loading event to notify the client
					Reader.Notify.event(Reader.Event.LOADING_STARTED);
					_loading_required = true;
				}
			);
		},
		loadChapter: function loadChapter(){
			Reader.Notify.event(Reader.Event.LOADING_STARTED);
			return Reader.Navigation.loadChapter.apply(Reader.Navigation, arguments).always(function loadChapterComplete(){
				Reader.Notify.event(Reader.Event.LOADING_COMPLETE);
			}).then(
				function loadChapterSuccess(){
					_send_status('loadChapter');
				}, function loadChapterFail(err){
					Reader.Notify.error(err);
				}
			);
		},
		getProgress: Reader.Navigation.getProgress,
		getTOC: Reader.getTOC,
		getSPINE: Reader.getSPINE,
		getBookmarks: Reader.Bookmarks.getBookmarks,
		setBookmarks: _status_wrap(Reader.Bookmarks.setBookmarks, 'setBookmarks'),
		setBookmark: _status_wrap(Reader.Bookmarks.setBookmark, 'setBookmark'),
		goToBookmark: function goToBookmark(){
			Reader.Notify.event(Reader.Event.LOADING_STARTED);
			return Reader.Bookmarks.goToBookmark.apply(Reader.Bookmarks, arguments).always(function goToCFIComplete(){
				Reader.Notify.event(Reader.Event.LOADING_COMPLETE);
			}).then(
				function goToBookmarkSuccess(){
					_send_status('goToBookmark');
				}, function goToBookmarkFail(err){
					Reader.Notify.error(err);
				}
			);
		},
		removeBookmark: _status_wrap(Reader.Bookmarks.removeBookmark, 'removeBookmark'),
		showHeaderAndFooter: Reader.showHeaderAndFooter,
		hideHeaderAndFooter: Reader.hideHeaderAndFooter,
		resizeContainer: _status_wrap(Reader.resizeContainer, 'resizeContainer'),
		Event: Reader.Event,
		refreshLayout: _status_wrap(Reader.refreshLayout, 'refreshLayout'),
		enableDebug: Reader.Debug.enable,
		disableDebug: Reader.Debug.disable
	};
}());